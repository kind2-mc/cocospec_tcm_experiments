-- This file has been generated by CocoSim compiler + verifier

include "helpers.lus"

-- System nodes
node MODE_LOGIC_SpeedMode (Actiavte_1_1 : real; Deactivate_1_1 : real; AltEng_1_1 : bool; CAS_1_1 : real; CASCmdMCP_1_1 : real; )
returns (ATEng_1_1 : bool;
	CASCmd_2_1 : real) ;
var
	Add_1_1 : int;
	CompareToConstant_1_1 : bool;
	CompareToConstant1_1_1 : bool;
	LogicalOperator_1_1 : bool;
	LogicalOperator2_1_1 : bool;
	Switch_1_1 : real;
	Switch1_1_1 : real;
	SRFlipFlopRepl_dot__LogicalOperator_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator1_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator2_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator3_1_1 : bool;
	SRFlipFlopRepl_dot__UnitDelay_1_1 : bool;
	SRFlipFlopRepl_dot__UnitDelay1_1_1 : bool;
	UnitDelay2_1_1 : real;
let 
	Add_1_1 = (if CompareToConstant1_1_1 then 1 else 0) + (if LogicalOperator_1_1 then 1 else 0);
	CompareToConstant_1_1 = not(Deactivate_1_1 = 0.0000000000);
	CompareToConstant1_1_1 = not(Actiavte_1_1 = 0.0000000000);
	LogicalOperator_1_1 = AltEng_1_1 and SRFlipFlopRepl_dot__LogicalOperator_1_1;
	LogicalOperator2_1_1 = CompareToConstant1_1_1 or LogicalOperator_1_1;
	Switch_1_1 = if Add_1_1 >= 0 then UnitDelay2_1_1 else Switch1_1_1;
	Switch1_1_1 = if Add_1_1 > 1 then CASCmdMCP_1_1 else CAS_1_1;
	SRFlipFlopRepl_dot__LogicalOperator_1_1 = not(SRFlipFlopRepl_dot__UnitDelay_1_1 and SRFlipFlopRepl_dot__LogicalOperator3_1_1);
	SRFlipFlopRepl_dot__LogicalOperator1_1_1 = not(SRFlipFlopRepl_dot__LogicalOperator2_1_1 and SRFlipFlopRepl_dot__UnitDelay1_1_1);
	SRFlipFlopRepl_dot__LogicalOperator2_1_1 = not LogicalOperator2_1_1;
	SRFlipFlopRepl_dot__LogicalOperator3_1_1 = not CompareToConstant_1_1;
	SRFlipFlopRepl_dot__UnitDelay_1_1 = false -> pre SRFlipFlopRepl_dot__LogicalOperator1_1_1;
	SRFlipFlopRepl_dot__UnitDelay1_1_1 = true -> pre SRFlipFlopRepl_dot__LogicalOperator_1_1;
	UnitDelay2_1_1 = 0.0000000000 -> pre Switch_1_1;
	ATEng_1_1 = SRFlipFlopRepl_dot__LogicalOperator1_1_1;
	CASCmd_2_1 = UnitDelay2_1_1;
tel

node MODE_LOGIC_HeadingMode (
  Actiavte_1_1 : real; Deactivate_1_1 : bool
) returns (HeadEng_1_1 : bool) ;

(*@contract

  var head_eng_out = HeadEng_1_1 ;
  var head_eng_in = Actiavte_1_1 <> 0.0 ;
  var deactivate = Deactivate_1_1 ;

  var deactivation = false -> pre deactivate ;

  (* Head requested and no deactivation since then. *)
  var head_requested = has_been_true_reset(
    head_eng_in, deactivation and not head_eng_in
  ) ;

  (* System does not behave well when inputs rise and fall immediately.
    Following assumptions say that when an input changes value, it keeps the
    new value for at least 2 cycles. *)
  @require true ->
    (since(head_eng_in) = 1) => (pre since(not head_eng_in) > 1) ;
  @require true ->
    (since(not head_eng_in) = 1) => (pre since(head_eng_in) > 1) ;
  @require true ->
    (since(deactivate) = 1) => (pre since(not deactivate) > 1) ;
  @require true ->
    (since(not deactivate) = 1) => (pre since(deactivate) > 1) ;

  (* System does not behave well when an input and deactivate fall at the same
    time. *)
  @require fall(head_eng_in) => not fall(deactivate) ;



  @mode inactive (
    @require duration(not head_eng_in) > 0 ;
    @ensure not head_eng_out ;
  ) ;

  @mode deactivating (
    (* No collision with inactive mode. *)
    @require duration(not head_eng_in) = 0 ;
    @require not head_requested ;
    @require not head_eng_in ;
    @ensure not head_eng_out ;
  ) ;

  (* |===| Guide 250. *)
  @mode guide_250 (
    @require head_requested ;
    @ensure head_eng_out ;
  ) ;
*)

var
	CompareToConstant_1_1 : bool;
	CompareToConstant1_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator1_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator2_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator3_1_1 : bool;
	SRFlipFlopRepl_dot__UnitDelay_1_1 : bool;
	SRFlipFlopRepl_dot__UnitDelay1_1_1 : bool;
let 
	CompareToConstant_1_1 = not((if Deactivate_1_1 then 1.0 else 0.0) = 0.0000000000);
	CompareToConstant1_1_1 = not(Actiavte_1_1 = 0.0000000000);
	SRFlipFlopRepl_dot__LogicalOperator_1_1 = not(SRFlipFlopRepl_dot__UnitDelay_1_1 and SRFlipFlopRepl_dot__LogicalOperator3_1_1);
	SRFlipFlopRepl_dot__LogicalOperator1_1_1 = not(SRFlipFlopRepl_dot__LogicalOperator2_1_1 and SRFlipFlopRepl_dot__UnitDelay1_1_1);
	SRFlipFlopRepl_dot__LogicalOperator2_1_1 = not CompareToConstant1_1_1;
	SRFlipFlopRepl_dot__LogicalOperator3_1_1 = not CompareToConstant_1_1;
	SRFlipFlopRepl_dot__UnitDelay_1_1 = false -> pre SRFlipFlopRepl_dot__LogicalOperator1_1_1;
	SRFlipFlopRepl_dot__UnitDelay1_1_1 = true -> pre SRFlipFlopRepl_dot__LogicalOperator_1_1;
	HeadEng_1_1 = SRFlipFlopRepl_dot__LogicalOperator1_1_1;
tel

node MODE_LOGIC_AltAndFPAMode (
  ActiavteFPA_1_1 : real; Deactivate_1_1 : bool;
  Altitude_1_1, AltCmd_1_1, ActiavteAlt_1_1 : real
) returns (
  AltEng_1_1 : bool; FPAEng_2_1 : bool
) ;

(*@contract

  var alt_eng_out = AltEng_1_1 ;
  var fpa_eng_out = FPAEng_2_1 ;

  (* Helpers for component activation. *)
  var alt_eng_in = (ActiavteAlt_1_1 <> 0.0) ;
  var fpa_eng_in = (ActiavteFPA_1_1 <> 0.0) ;
  var deactivate = Deactivate_1_1 ;
  var deactivation = false -> pre deactivate ;

  (* Alt requested and no deactivation since then. *)
  var alt_requested =
    has_been_true_reset(alt_eng_in, deactivation and not alt_eng_in) ;
  (* FPA requested and no deactivation since then. *)
  var fpa_requested =
    has_been_true_reset(fpa_eng_in, deactivation and not fpa_eng_in) ;

  (* Separates Guide 210 (not far_altitude_gap) from Guide 170/180
    (far_altitude_gap). In the former Alt has priority, while in the latter
    it's FPA. *)
  var far_altitude_gap = abs(Altitude_1_1 - AltCmd_1_1) > 200.0 ;

  (* The following assumptions say that [alt_eng_in], [fpa_eng_in] and
    [deactivation] cannot change too fast. It can only change from [v] to [not
    v] if it had value [v] for at least two steps.

    The system remembers which mode were requested since the last deactivation
    and activates whoever has priority, depending on the width of the gap
    between the actual altitude and the altitude command.

    But it seems a request is only remembered if it lasts for more than one
    cycle. My understanding is that in this case, the relevant mode is still
    activated for this one cycle, but that's all.

    I tried to specify the system for this behavior, and it worked to some
    extent, but the spec was way messier. More importantly, when there are
    alternations of one-cycle-long requests for Alt and FPA the system just
    stops making any sense to me. I might be missing something, but when in
    addition [deactivation] is allowed to spike for a single cycle, it becomes a
    nightmare.

    Example of very confusing trace:
    Node MODE_LOGIC_AltAndFPAMode ()
     == Inputs ==
     ActiavteFPA_1_1                               0     0     0     0     0
     Deactivate_1_1                             true  true false false false
     Altitude_1_1                                201  -201    -1     0   201
     AltCmd_1_1                                    0     0     0   200     0
     ActiavteAlt_1_1                               0     0     6     0     0
     == Outputs ==
     AltEng_1_1                                false false  true false  true
     FPAEng_2_1                                false false false false false
    Notice that there's an Alt request in step 3 that's not confirmed so Alt is
    active in step 3 but not step 4. However for some reason it is activated
    again in step 5 even though there's no request at all... *)
  @require true ->
    (since(alt_eng_in) = 1) => (pre since(not alt_eng_in) > 1) ;
  @require true ->
    (since(not alt_eng_in) = 1) => (pre since(alt_eng_in) > 1) ;
  @require true ->
    (since(fpa_eng_in) = 1) => (pre since(not fpa_eng_in) > 1) ;
  @require true ->
    (since(not fpa_eng_in) = 1) => (pre since(fpa_eng_in) > 1) ;
  @require true ->
    (since(deactivate) = 1) => (pre since(not deactivate) > 1) ;
  @require true ->
    (since(not deactivate) = 1) => (pre since(deactivate) > 1) ;

  (* System does not behave well when an input and deactivate fall at the same
    time. *)
  @require fall(alt_eng_in) => not fall(deactivate) ;
  @require fall(fpa_eng_in) => not fall(deactivate) ;

  (* Whatever happens, altitude control and FPA control can't be active at the
    same time. *)
  @ensure not (alt_eng_out and fpa_eng_out) ;


  (* If there's been no request for FPA or Alt since the beginning, no one is
    engaged. *)
  @mode inactive (
    @require duration(not (alt_eng_in or fpa_eng_in)) > 0 ;
    @ensure not (alt_eng_out or fpa_eng_out) ;
  ) ;

  (* When deactivated no one is active. *)
  @mode deactivated (
    (* No collision with inactive mode. *)
    @require duration(not (alt_eng_in or fpa_eng_in)) = 0 ;
    @require not alt_requested ;
    @require not fpa_requested ;
    @ensure not (alt_eng_out or fpa_eng_out) ;
  ) ;


  (* |===| Guide 170.
    Alt does not have priority. It cannot be active if FPA was requested since
    the beginning / last deactivation, or if a deactivation happened since the
    last request for Alt. *)
  @mode guide_170_alt (
    @require far_altitude_gap ;
    @require alt_requested ;
    @require not fpa_requested ;
    @ensure alt_eng_out or (fpa_eng_out and not fpa_eng_out) ;
  ) ;

  (* |===| Guide 180.
    FPA has priority. It is active if no deactivation happened since the last
    FPA request. *)
  @mode guide_180_fpa (
    @require far_altitude_gap ;
    @require fpa_requested ;
    @ensure fpa_eng_out or (alt_eng_out and not alt_eng_out) ;
  ) ;

  (* |===| Guide 210, Alt mode.
    Alt has priority. It is active if no deactivation happened since the last
    Alt request. *)
  @mode guide_210_alt (
    @require not far_altitude_gap ;
    @require alt_requested ;
    @ensure alt_eng_out or (fpa_eng_out and not fpa_eng_out) ;
  ) ;

  (* |===| Guide 210, FPA mode.
    FPA does not have priority. It cannot be active if Alt was requested since
    the beginning / last deactivation, or if a deactivation happened since the
    last request for FPA. *)
  @mode guide_210_fpa (
    @require not far_altitude_gap ;
    @require fpa_requested ;
    @require not alt_requested ;
    @ensure fpa_eng_out or (alt_eng_out and not alt_eng_out) ;
  ) ;
*)


var
	Abs_1_1 : real;
	Add_1_1 : real;
	CompareToConstant_1_1 : bool;
	CompareToConstant1_1_1 : bool;
	CompareToConstant2_1_1 : bool;
	CompareToConstant3_1_1 : bool;
	LogicalOperator1_1_1 : bool;
	LogicalOperator2_1_1 : bool;
	LogicalOperator3_1_1 : bool;
	LogicalOperator4_1_1 : bool;
	LogicalOperator6_1_1 : bool;
	SRFlipFlopRepl_dot_1_LogicalOperator_1_1 : bool;
	SRFlipFlopRepl_dot_1_LogicalOperator1_1_1 : bool;
	SRFlipFlopRepl_dot_1_LogicalOperator2_1_1 : bool;
	SRFlipFlopRepl_dot_1_LogicalOperator3_1_1 : bool;
	SRFlipFlopRepl_dot_1_UnitDelay_1_1 : bool;
	SRFlipFlopRepl_dot_1_UnitDelay1_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator1_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator2_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator3_1_1 : bool;
	SRFlipFlopRepl_dot__UnitDelay_1_1 : bool;
	SRFlipFlopRepl_dot__UnitDelay1_1_1 : bool;
let 
	Abs_1_1 = if Add_1_1 >= 0.0 then Add_1_1 else -Add_1_1;
	Add_1_1 = Altitude_1_1 - AltCmd_1_1;
	CompareToConstant_1_1 = not((if Deactivate_1_1 then 1.0 else 0.0) = 0.0000000000);
	CompareToConstant1_1_1 = not(ActiavteFPA_1_1 = 0.0000000000);
	CompareToConstant2_1_1 = Abs_1_1 <= 200.0000000000;
	CompareToConstant3_1_1 = not(ActiavteAlt_1_1 = 0.0000000000);
	LogicalOperator1_1_1 = LogicalOperator2_1_1 or CompareToConstant2_1_1;
	LogicalOperator2_1_1 = not SRFlipFlopRepl_dot__LogicalOperator1_1_1;
	LogicalOperator3_1_1 = SRFlipFlopRepl_dot__LogicalOperator1_1_1 and LogicalOperator6_1_1;
	LogicalOperator4_1_1 = SRFlipFlopRepl_dot_1_LogicalOperator1_1_1 and LogicalOperator1_1_1;
	LogicalOperator6_1_1 = not(SRFlipFlopRepl_dot_1_LogicalOperator1_1_1 and CompareToConstant2_1_1);
	SRFlipFlopRepl_dot_1_LogicalOperator_1_1 = not(SRFlipFlopRepl_dot_1_UnitDelay_1_1 and SRFlipFlopRepl_dot_1_LogicalOperator3_1_1);
	SRFlipFlopRepl_dot_1_LogicalOperator1_1_1 = not(SRFlipFlopRepl_dot_1_LogicalOperator2_1_1 and SRFlipFlopRepl_dot_1_UnitDelay1_1_1);
	SRFlipFlopRepl_dot_1_LogicalOperator2_1_1 = not CompareToConstant3_1_1;
	SRFlipFlopRepl_dot_1_LogicalOperator3_1_1 = not CompareToConstant_1_1;
	SRFlipFlopRepl_dot_1_UnitDelay_1_1 = false -> pre SRFlipFlopRepl_dot_1_LogicalOperator1_1_1;
	SRFlipFlopRepl_dot_1_UnitDelay1_1_1 = true -> pre SRFlipFlopRepl_dot_1_LogicalOperator_1_1;
	SRFlipFlopRepl_dot__LogicalOperator_1_1 = not(SRFlipFlopRepl_dot__UnitDelay_1_1 and SRFlipFlopRepl_dot__LogicalOperator3_1_1);
	SRFlipFlopRepl_dot__LogicalOperator1_1_1 = not(SRFlipFlopRepl_dot__LogicalOperator2_1_1 and SRFlipFlopRepl_dot__UnitDelay1_1_1);
	SRFlipFlopRepl_dot__LogicalOperator2_1_1 = not CompareToConstant1_1_1;
	SRFlipFlopRepl_dot__LogicalOperator3_1_1 = not CompareToConstant_1_1;
	SRFlipFlopRepl_dot__UnitDelay_1_1 = false -> pre SRFlipFlopRepl_dot__LogicalOperator1_1_1;
	SRFlipFlopRepl_dot__UnitDelay1_1_1 = true -> pre SRFlipFlopRepl_dot__LogicalOperator_1_1;
	AltEng_1_1 = LogicalOperator4_1_1;
	FPAEng_2_1 = LogicalOperator3_1_1;
tel

node MODE_LOGIC (HeadMode_1_1 : real; ailStick_1_1 : real; elevStick_1_1 : real; AltMode_1_1 : real; FPAMode_1_1 : real; ATMode_1_1 : real; AltCmd_1_1 : real; Altitude_1_1 : real; CAS_1_1 : real; CASCmdMCP_1_1 : real; )
returns (HeadEng_1_1 : bool ;
	AltEng_2_1 : bool;
	FPAEng_3_1 : bool;
	ATEng_4_1 : bool;
	CASCmd_5_1 : real) ;

(*@contract
  var alt_eng_out = AltEng_2_1 ;
  var fpa_eng_out = FPAEng_3_1 ;
  var head_eng_out = HeadEng_1_1 ;

  (* Helpers for component activation. *)
  var alt_eng_in = (AltMode_1_1 <> 0.0) ;
  var fpa_eng_in = (FPAMode_1_1 <> 0.0) ;
  var head_eng_in = (HeadMode_1_1 <> 0.0) ;
  var deactivate = (ailStick_1_1 <> 0.0 or elevStick_1_1 <> 0.0) ;
  var deactivation = false -> pre deactivate ;

  (* Alt requested and no deactivation since then. *)
  var alt_requested = has_been_true_reset(
    alt_eng_in, deactivation and not alt_eng_in
  ) ;
  (* FPA requested and no deactivation since then. *)
  var fpa_requested = has_been_true_reset(
    fpa_eng_in, deactivation and not fpa_eng_in
  ) ;
  (* Head requested and no deactivation since then. *)
  var head_requested = has_been_true_reset(
    head_eng_in, deactivation and not head_eng_in
  ) ;

  (* Separates Guide 210 (not far_altitude_gap) from Guide 170/180
    (far_altitude_gap). In the former Alt has priority, while in the latter
    it's FPA. *)
  var far_altitude_gap = abs(Altitude_1_1 - AltCmd_1_1) > 200.0 ;

  (* See "MODE_LOGIC_HeadingMode" for an explanation of the following. *)
  @require true ->
    (since(head_eng_in) = 1) => (pre since(not head_eng_in) > 1) ;
  @require true ->
    (since(not head_eng_in) = 1) => (pre since(head_eng_in) > 1) ;
  (* See "MODE_LOGIC_AltAndFPAMode" for an explanation of the following. *)
  @require true ->
    (since(alt_eng_in) = 1) => (pre since(not alt_eng_in) > 1) ;
  @require true ->
    (since(not alt_eng_in) = 1) => (pre since(alt_eng_in) > 1) ;
  @require true ->
    (since(fpa_eng_in) = 1) => (pre since(not fpa_eng_in) > 1) ;
  @require true ->
    (since(not fpa_eng_in) = 1) => (pre since(fpa_eng_in) > 1) ;
  @require true ->
    (since(deactivate) = 1) => (pre since(not deactivate) > 1) ;
  @require true ->
    (since(not deactivate) = 1) => (pre since(deactivate) > 1) ;

  (* System does not behave well when an input and deactivate fall at the same
    time. *)
  @require fall(alt_eng_in) => not fall(deactivate) ;
  @require fall(fpa_eng_in) => not fall(deactivate) ;
  (* System does not behave well when an input and deactivate fall at the same
    time. *)
  @require fall(head_eng_in) => not fall(deactivate) ;

  (* Whatever happens, altitude control and FPA control can't be active at the
    same time. *)
  @ensure not (alt_eng_out and fpa_eng_out) ;

  (* FPA cannot be engaged it it was never requested. *)
  @ensure not has_been_true(fpa_eng_in) => not fpa_eng_out ;
  (* Altitude cannot be engaged it it was never requested. *)
  @ensure not has_been_true(alt_eng_in) => not alt_eng_out ;
  (* Head cannot be engaged it it was never requested. *)
  @ensure not has_been_true(head_eng_in) => not head_eng_out ;



  @mode inactive (
    @require duration(not (alt_eng_in or fpa_eng_in or head_eng_in)) > 0 ;
    @ensure not (alt_eng_out or fpa_eng_out or head_eng_in) ;
  ) ;

  (* When deactivated no one is active. *)
  @mode deactivated (
    (* No collision with inactive mode. *)
    @require not inactive ;
    @require not alt_requested ;
    @require not fpa_requested ;
    @require not head_requested ;
    @ensure not (alt_eng_out or fpa_eng_out or head_eng_out) ;
  ) ;


  (* |===| Guide 170.
    Alt does not have priority. It cannot be active if FPA was requested since
    the beginning / last deactivation, or if a deactivation happened since the
    last request for Alt. *)
  @mode guide_170_alt (
    @require far_altitude_gap ;
    @require alt_requested ;
    @require not fpa_requested ;
    @ensure alt_eng_out or (fpa_eng_out and not fpa_eng_out) ;
  ) ;

  (* |===| Guide 180.
    FPA has priority. It is active if no deactivation happened since the last
    FPA request. *)
  @mode guide_180_fpa (
    @require far_altitude_gap ;
    @require fpa_requested ;
    @ensure fpa_eng_out or (alt_eng_out and not alt_eng_out) ;
  ) ;

  (* |===| Guide 210, Alt mode.
    Alt has priority. It is active if no deactivation happened since the last
    Alt request. *)
  @mode guide_210_alt (
    @require not far_altitude_gap ;
    @require alt_requested ;
    @ensure alt_eng_out or (fpa_eng_out and not fpa_eng_out) ;
  ) ;

  (* |===| Guide 210, FPA mode.
    FPA does not have priority. It cannot be active if Alt was requested since
    the beginning / last deactivation, or if a deactivation happened since the
    last request for FPA. *)
  @mode guide_210_fpa (
    @require not far_altitude_gap ;
    @require fpa_requested ;
    @require not alt_requested ;
    @ensure fpa_eng_out or (alt_eng_out and not alt_eng_out) ;
  ) ;

  (* Altitude and FPA modes cannot be engaged outside of the spec. *)
  @mode alt_and_fpa_inactive (
    (* No intersection with deactivated. *)
    @require not deactivated ;
    @require not guide_170_alt ;
    @require not guide_180_fpa ;
    @require not guide_210_alt ;
    @require not guide_210_fpa ;
    @ensure not fpa_eng_out ;
    @ensure not alt_eng_out ;
  ) ;

  (* |===| Guide 250. *)
  @mode guide_250 (
    @require head_requested ;
    @ensure head_eng_out ;
  ) ;
*)

var
	AltAndFPAMode_1_1 : bool; AltAndFPAMode_2_1 : bool;
	CompareToZero_1_1 : bool;
	CompareToZero1_1_1 : bool;
	Constant_1_1 : real;
	HeadingMode_1_1 : bool;
	LogicalOperator_1_1 : bool;
	SpeedMode_1_1 : bool; SpeedMode_2_1 : real;
let 
	(AltAndFPAMode_1_1, AltAndFPAMode_2_1) = MODE_LOGIC_AltAndFPAMode(FPAMode_1_1, LogicalOperator_1_1, Altitude_1_1, AltCmd_1_1, AltMode_1_1);
	CompareToZero_1_1 = not(ailStick_1_1 = 0.0000000000);
	CompareToZero1_1_1 = not(elevStick_1_1 = 0.0000000000);
	Constant_1_1 = 0.0000000000;
	HeadingMode_1_1 = MODE_LOGIC_HeadingMode(HeadMode_1_1, LogicalOperator_1_1);
	LogicalOperator_1_1 = CompareToZero_1_1 or CompareToZero1_1_1;
	(SpeedMode_1_1, SpeedMode_2_1) = MODE_LOGIC_SpeedMode(ATMode_1_1, Constant_1_1, AltAndFPAMode_2_1, CAS_1_1, CASCmdMCP_1_1);
	HeadEng_1_1 = HeadingMode_1_1;
	AltEng_2_1 = AltAndFPAMode_1_1;
	FPAEng_3_1 = AltAndFPAMode_2_1;
	ATEng_4_1 = SpeedMode_1_1;
	CASCmd_5_1 = SpeedMode_2_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_2 (In1_1_1 : real; x1_1_1 : real; x2_1_1 : real; y1_1_1 : real; y2_1_1 : real; )
returns (Out1_1_1 : real) ;
var
	Add1_1_1 : real;
	Add2_1_1 : real;
	Add3_1_1 : real;
	Add4_1_1 : real;
	Divide_1_1 : real;
let 
	Add1_1_1 =  - x1_1_1 + x2_1_1;
	Add2_1_1 = Divide_1_1 + y1_1_1;
	Add3_1_1 =  - y1_1_1 + y2_1_1;
	Add4_1_1 = In1_1_1 - x1_1_1;
	-- Divide_1_1 = Add4_1_1 / Add1_1_1 * Add3_1_1;
	Divide_1_1 = times( divid(Add4_1_1, Add1_1_1), Add3_1_1 ) ;
	Out1_1_1 = Add2_1_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_1 (In1_1_1 : real; x1_1_1 : real; x2_1_1 : real; y1_1_1 : real; y2_1_1 : real; )
returns (Out1_1_1 : real) ;
var
	Add1_1_1 : real;
	Add2_1_1 : real;
	Add3_1_1 : real;
	Add4_1_1 : real;
	Divide_1_1 : real;
let 
	Add1_1_1 =  - x1_1_1 + x2_1_1;
	Add2_1_1 = Divide_1_1 + y1_1_1;
	Add3_1_1 =  - y1_1_1 + y2_1_1;
	Add4_1_1 = In1_1_1 - x1_1_1;
	-- Divide_1_1 = Add4_1_1 / Add1_1_1 * Add3_1_1;
	Divide_1_1 = times( divid(Add4_1_1, Add1_1_1), Add3_1_1 ) ;
	Out1_1_1 = Add2_1_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_0 (In1_1_1 : real; x1_1_1 : real; x2_1_1 : real; y1_1_1 : real; y2_1_1 : real; )
returns (Out1_1_1 : real) ;
var
	Add1_1_1 : real;
	Add2_1_1 : real;
	Add3_1_1 : real;
	Add4_1_1 : real;
	Divide_1_1 : real;
let 
	Add1_1_1 =  - x1_1_1 + x2_1_1;
	Add2_1_1 = Divide_1_1 + y1_1_1;
	Add3_1_1 =  - y1_1_1 + y2_1_1;
	Add4_1_1 = In1_1_1 - x1_1_1;
	-- Divide_1_1 = Add4_1_1 / Add1_1_1 * Add3_1_1;
	Divide_1_1 = times( divid(Add4_1_1, Add1_1_1), Add3_1_1 ) ;
	Out1_1_1 = Add2_1_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d (In1_1_1 : real; )
returns (Out1_1_1 : real) ;
var
	Add_1_1 : real;
	branch_sharp_1_1_1 : real;
	branch_sharp_2_1_1 : real;
	branch_sharp_3_1_1 : real;
	gte1_1_1 : bool;
	gte2_1_1 : bool;
	gte3_1_1 : bool;
	interpolate1d_sharp_0_1_1 : real;
	interpolate1d_sharp_1_1_1 : real;
	interpolate1d_sharp_2_1_1 : real;
	lte1_1_1 : bool;
	lte2_1_1 : bool;
	lte3_1_1 : bool;
	r1_1_1 : real;
	r2_1_1 : real;
	r3_1_1 : real;
	r4_1_1 : real;
	r5_1_1 : real;
	r6_1_1 : real;
	r7_1_1 : real;
	r8_1_1 : real;
let 
	Add_1_1 = branch_sharp_1_1_1 + branch_sharp_2_1_1 + branch_sharp_3_1_1;
	-- branch_sharp_1_1_1 = interpolate1d_sharp_0_1_1 * (if lte1_1_1 then 1.0 else 0.0) * (if gte1_1_1 then 1.0 else 0.0);
	branch_sharp_1_1_1 =
		if lte1_1_1 and gte1_1_1 then interpolate1d_sharp_0_1_1 else 0.0 ;
	-- branch_sharp_2_1_1 = interpolate1d_sharp_1_1_1 * (if lte2_1_1 then 1.0 else 0.0) * (if gte2_1_1 then 1.0 else 0.0);
	branch_sharp_2_1_1 =
		if lte2_1_1 and gte2_1_1 then interpolate1d_sharp_1_1_1 else 0.0 ;
	-- branch_sharp_3_1_1 = interpolate1d_sharp_2_1_1 * (if lte3_1_1 then 1.0 else 0.0) * (if gte3_1_1 then 1.0 else 0.0);
	branch_sharp_3_1_1 =
		if lte3_1_1 and gte3_1_1 then interpolate1d_sharp_2_1_1 else 0.0 ;
	gte1_1_1 = In1_1_1 <= r2_1_1;
	gte2_1_1 = In1_1_1 <= r3_1_1;
	gte3_1_1 = In1_1_1 <= r4_1_1;
	interpolate1d_sharp_0_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_0(In1_1_1, r1_1_1, r2_1_1, r5_1_1, r6_1_1);
	interpolate1d_sharp_1_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_1(In1_1_1, r2_1_1, r3_1_1, r6_1_1, r7_1_1);
	interpolate1d_sharp_2_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_2(In1_1_1, r3_1_1, r4_1_1, r7_1_1, r8_1_1);
	lte1_1_1 = In1_1_1 >= r1_1_1;
	lte2_1_1 = In1_1_1 > r2_1_1;
	lte3_1_1 = In1_1_1 > r3_1_1;
	r1_1_1 = 0.0000000000;
	r2_1_1 = 120.0000000000;
	r3_1_1 = 350.0000000000;
	r4_1_1 = 500.0000000000;
	r5_1_1 = 1.0000000000;
	r6_1_1 = 1.0000000000;
	r7_1_1 = 0.3000000000;
	r8_1_1 = 0.3000000000;
	Out1_1_1 = Add_1_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop_TransferFunc (u_1_1 : real; )
returns (y_1_1 : real) ;
var
	a_sharp_1_1_1 : real;
	b0_sharp_0_1_1 : real;
	b0_sharp_1_1_1 : real;
	delay_sharp_1_1_1 : real;
	output_sum_1_1 : real;
	sample_sharp_1_1_1 : real;
	sum11_1_1 : real;
	sum21_1_1 : real;
let 
	a_sharp_1_1_1 = 0.0625000000 * delay_sharp_1_1_1;
	b0_sharp_0_1_1 = 1.0000000000 * u_1_1;
	b0_sharp_1_1_1 = -1.0000000000 * a_sharp_1_1_1;
	delay_sharp_1_1_1 = 0.0000000000 -> pre sum21_1_1;
	output_sum_1_1 = b0_sharp_0_1_1 + b0_sharp_1_1_1;
	sample_sharp_1_1_1 = 0.0200000000 * sum11_1_1;
	sum11_1_1 = u_1_1 - a_sharp_1_1_1;
	sum21_1_1 = sample_sharp_1_1_1 + delay_sharp_1_1_1;
	y_1_1 = output_sum_1_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop (PitchCmd_1_1 : real; Pitch_1_1 : real; qdeg_1_1 : real; CAS_1_1 : real; )
returns (ElevCmd_1_1 : real) ;
var
	Kpitch_1_1 : real;
	Kwo_1_1 : real;
	Mux_1_1 : real; Mux_1_2 : real;
	Product_1_1 : real;
	Sum_1_1 : real;
	Sum1_1_1 : real;
	TransferFunc_1_1 : real;
	lookup1d_1_1 : real;
let 
	Kpitch_1_1 = 2.0000000000 * Sum_1_1;
	Kwo_1_1 = 0.5000000000 * TransferFunc_1_1;
	Mux_1_1 = PitchCmd_1_1 ;
	Mux_1_2 = Pitch_1_1 ;
	-- Product_1_1 = Sum1_1_1 * lookup1d_1_1 ;
	Product_1_1 = times(Sum1_1_1, lookup1d_1_1);
	Sum_1_1 = PitchCmd_1_1 - Pitch_1_1;
	Sum1_1_1 =  - Kpitch_1_1 + Kwo_1_1;
	TransferFunc_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop_TransferFunc(qdeg_1_1);
	lookup1d_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d(CAS_1_1);
	ElevCmd_1_1 = Product_1_1;
tel

node LONGITUDINAL_CONTROLLER_ManualOverride (Man_1_1 : real; Auto_1_1 : real; )
returns (Out_1_1 : real) ;
var
	Switch1_1_1 : real;
let 
  -- Switch1_1_1 = if not(Man_1_1 = 0.0) then Auto_1_1 else Man_1_1;
  Switch1_1_1 = if Man_1_1 <> 0.0 then Man_1_1 else Auto_1_1 ;
	Out_1_1 = Switch1_1_1;
tel

node LONGITUDINAL_CONTROLLER_FPAControl_integrator_reset (f_lpar_x_rpar__1_1 : real; reset_level_1_1 : bool; x0_1_1 : real; )
returns (F_lpar_x_rpar__1_1 : real) ;
var
	Add_1_1 : real;
	Constant_1_1 : real;
	Gain1_1_1 : real;
	Product_1_1 : real;
	Product1_1_1 : real;
	Product2_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	delay_sharp_1_1_1 : real;
	delay_sharp_2_1_1 : real;
	delay_sharp_3_1_1 : bool;
	eq0_1_1 : bool;
	ne0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Add_1_1 = Product1_1_1 + Product2_1_1;
	Constant_1_1 = 0.0000000000;
	Gain1_1_1 = 1.0000000000 * f_lpar_x_rpar__1_1;
  -- Actually linear {
	--   Product_1_1 = x0_1_1 * delay_sharp_1_1_1 ;
  -- }
	-- Product_1_1 = times(x0_1_1, delay_sharp_1_1_1) ;
  Product_1_1 = x0_1_1 -> 0.0 ;
	-- Product1_1_1 = Sum3_1_1 * (if ne0_1_1 then 1.0 else 0.0);
	Product1_1_1 = if ne0_1_1 then Sum3_1_1 else 0.0 ;
	-- Product2_1_1 = (if eq0_1_1 then 1.0 else 0.0) * Sum3_1_1 * (if ne1_1_1 then 1.0 else 0.0);
	Product2_1_1 = if eq0_1_1 and ne1_1_1 then Sum3_1_1 else 0.0 ;
	Sum1_1_1 = Gain1_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - delay_sharp_2_1_1 + x0_1_1;
	Sum4_1_1 = delay_sharp_2_1_1 + Add_1_1;
	delay_sharp_1_1_1 = 1.0000000000 -> pre Constant_1_1;
	delay_sharp_2_1_1 = 0.0000000000 -> pre Sum1_1_1;
	delay_sharp_3_1_1 = false -> pre reset_level_1_1;
	eq0_1_1 = (if reset_level_1_1 then 1.0 else 0.0) = zero_1_1;
	ne0_1_1 = not((if reset_level_1_1 then 1.0 else 0.0) = zero_1_1);
	ne1_1_1 = not((if delay_sharp_3_1_1 then 1.0 else 0.0) = zero_1_1);
	zero_1_1 = 0.0000000000;
	F_lpar_x_rpar__1_1 = delay_sharp_2_1_1;
tel

node LONGITUDINAL_CONTROLLER_FPAControl_DynamicSaturation (up_1_1 : real; u_1_1 : real; lo_1_1 : real; )
returns (y1_1_1 : real) ;
var
	LowerRelop1_1_1 : bool;
	Switch_1_1 : real;
	Switch2_1_1 : real;
	UpperRelop_1_1 : bool;
let 
	LowerRelop1_1_1 = u_1_1 > up_1_1;
	Switch_1_1 = if UpperRelop_1_1 then lo_1_1 else u_1_1;
	Switch2_1_1 = if LowerRelop1_1_1 then up_1_1 else Switch_1_1;
	UpperRelop_1_1 = u_1_1 < lo_1_1;
	y1_1_1 = Switch2_1_1;
tel

node LONGITUDINAL_CONTROLLER_FPAControl (engage_1_1 : bool; gamcmd_1_1 : real; gamma_1_1 : real; thetadeg_1_1 : real; VT_1_1 : real; )
returns (PitchCmd_1_1 : real) ;

(*@contract

  (* Engaged flag. *)
  var fpa_eng_in = engage_1_1 ;
  (* FPA command. *)
  var fpa_cmd_in = gamcmd_1_1 ;
  var pre_fpa_cmd_in = fpa_cmd_in -> pre fpa_cmd_in ;
  (* Actual FPA. *)
  var fpa_in = gamma_1_1 ;
  (* Actual pitch (theta). *)
  var pitch_in = thetadeg_1_1 ;
  (* Speed of the aircraft. *)
  var speed_in = VT_1_1 ;


  (* ## Output. *)

  (* Pitch command. *)
  var pitch_cmd_out = PitchCmd_1_1 ;
  var pre_pitch_cmd_out = pitch_cmd_out -> pre pitch_cmd_out ;


  (* ## Helper variable. *)

  (* True if the fpa command hasn't changed. *)
  var cmd_stable = fpa_cmd_in = pre_fpa_cmd_in ;

  var pitch_diff_ubound = 4.83 * 57.2958 * 1.6878 * speed_in ;

  var safe_pitch_diff = (
    if fpa_cmd_in - fpa_in > pitch_diff_ubound then pitch_diff_ubound
    else if fpa_cmd_in - fpa_in < - pitch_diff_ubound then - pitch_diff_ubound
    else fpa_cmd_in - fpa_in
  ) ;
  -- 
  -- var intgr = integrator_reset(
  --   safe_pitch_diff,
  --   pitch_in + 1.4 * fpa_in,
  --   not fpa_eng_in
  -- ) ;

  (* Raising means that the pitch command is above the current pitch, above
    its previous value, or that FPA is expected to reach/ go above the FPA
    command in the next step. *)
  var raising = 
    pitch_cmd_out > pitch_in or
    pitch_cmd_out >= pre_pitch_cmd_out or
    fpa_cmd_in <= fpa_in + (0.0 -> fpa_in - pre fpa_in) ;
  (* Lowering means that the pitch command is below the current pitch, below
    its previous value, or that FPA is expected to reach/ go below the FPA
    command in the next step. *)
  var lowering =
    pitch_cmd_out < pitch_in or
    pitch_cmd_out <= pre_pitch_cmd_out or
    fpa_cmd_in >= fpa_in + (0.0 -> fpa_in - pre fpa_in) ;


  (* Speed is positive. *)
  @require speed_in >= 0.0 ;

  (* We're not engaged initially. *)
  -- @require not fpa_eng_in -> true ;
  (* We start with pitch and FPA at 0. *)
  -- @require pitch_in = 0.0 -> true ;
  -- @require fpa_in = 0.0 -> true ;


  (* ## Pseudo-closed-loop assumptions. *)

  (* Pitch cannot change too fast. *)
  -- @require PseudoContinuous(pitch_in, 1.0) ;
  (* Neither can FPA. *)
  -- @require PseudoContinuous(fpa_in, 1.0) ;
  (* Neither can FPA command. *)
  -- @require PseudoContinuous(fpa_cmd_in, 1.0) ;
  (* Pitch command is immediate when we're engaged. *)
  -- @require true -> (
  --   fpa_eng_in and pre fpa_eng_in => pitch_in = pre pitch_cmd_out
  -- ) ;
  (* Super strong relation between pitch and FPA. *)
  -- @require pitch_in = 1.4 * fpa_in ;

  (* The following pseudo-loop constraints are what we'd like to use. Contract
    seems to hold but we can't prove it... *)
  (* Pitch converges towards pitch command.
    Ideally we want this and not the previous one. *)
  @require true -> (
    pre fpa_eng_in => (
      abs(pitch_in - pre_pitch_cmd_out) < pre abs(pitch_in - pitch_cmd_out) or
      (pre pitch_in) = pre_pitch_cmd_out
    )
  ) ;
  (* Link between pitch and FPA. *)
  (* FPA and theta have same sign, and abs(fpa) < (theta). *)
--   @require (pitch_in = 0.0 => fpa_in = 0.0) ;
--   @require true -> (
--     pitch_in > 0.0 => (
--       pitch_in > fpa_in and fpa_in >= pitch_in / 1.4
--     )
--   ) ;
--   @require true -> (
--     pitch_in < 0.0 => (
--       pitch_in / 1.4 >= fpa_in and fpa_in > pitch_in
--     )
--   ) ;
  (* Derivatives of FPA and pitch have the same sign. *)
  @require true -> ( (pitch_in > pre pitch_in) = (fpa_in > pre fpa_in) ) ;
  @require true -> ( (pitch_in < pre pitch_in) = (fpa_in < pre fpa_in) ) ;
  @require true -> ( (pitch_in = pre pitch_in) = (fpa_in = pre fpa_in) ) ;


  (* Cannot be engaged if speed is less than 100. *)
  @require speed_in < 100.0 => not fpa_eng_in ;
  (* When engaging actual FPA and command must match. *)
  -- @require true -> (
  --   rise(fpa_eng_in) => (
  --     abs(fpa_in - fpa_cmd_in) < 0.001
  --   )
  -- ) ;


  (* |===| "Pitch command clamped by aircraft limitations." Probably.
    Constants come from the system, no idea what they mean.

    System acts weird when fpa_eng_in_in is true in the initial state. We thus
    request that at least a deactivation occured. *)
  -- @ensure (true -> has_been_true(not fpa_eng_in)) => (
  --   fpa_eng_in =>
  --     abs(pitch_in - pitch_cmd_out) <= 4.83 * 57.2958 * 1.6878 * speed_in
  -- ) ;



  (* Sometimes this helps in proving stuff. It seems like it does not with the
    current spec. *)
  -- @ensure pitch_cmd_out = intgr - 1.4 * fpa_in ;


  (* |===| Modes. *)

  (* Not activated.
    Seems to me the ensure here should be that pitch_cmd_out = pitch_in. *)
  @mode deactivated (
    @require not fpa_eng_in ;
    @ensure true -> (
      (has_been_true(fpa_eng_in) and pre not fpa_eng_in) => (
        pitch_cmd_out = (
          pre (safe_pitch_diff + pitch_in + 1.4 * fpa_in)
        ) - 1.4 * fpa_in
      )
    ) ;
  ) ;

  @mode fpa_engaging (
    @require fpa_eng_in -> rise(fpa_eng_in) ;
  ) ;

  (* |===| Guide 120/130, raising. *)
  @mode g120_130_raising (
    @require fpa_eng_in ;
    @require false -> pre fpa_eng_in ;
    @require fpa_cmd_in > fpa_in ;
    @ensure (
      (* Not confirmed that we're climbing. *)
      (false -> pre (fpa_cmd_in <= fpa_in)) or
      (* Pitch was at pitch command. *)
      (false -> pre (pitch_in = pitch_cmd_out)) or
      (* Climbing. *)
      raising or
      (* We're not climbing but we were in the previous state. *)
      ( not raising and (false -> pre raising) )
    ) ;
  ) ;

  (* |===| Guide 120/130, lowering. *)
  @mode g120_130_lowering (
    @require fpa_eng_in ;
    @require false -> pre fpa_eng_in ;
    @require fpa_cmd_in < fpa_in ;
    @ensure (
      (* Not confirmed that we're descending. *)
      (false -> pre (fpa_cmd_in >= fpa_in)) or
      (* Pitch was at pitch command. *)
      (false -> pre (pitch_in = pitch_cmd_out)) or
      (* descending. *)
      lowering or
      (* We're not descending but we were in the previous state. *)
      ( not lowering and (false -> pre lowering) )
    ) ;
  ) ;

  (* |===| Guide 120/130, stabilizing version.
    Things get tricky when we get to the requested FPA. Not sure what the
    ensure should be here. This mode cannot be active for two consecutive
    states though because of `count_succ_true(...) = 1` unless the command
    changes. *)
  @mode g120_130_stabilizing (
    @require fpa_eng_in ;
    @require (
      (not cmd_stable) or
      -- (false -> not pre fpa_eng_in) or
      -- (false -> (fpa_cmd_in < fpa <> pre (fpa_cmd_in < fpa))) or
      count_succ_true(fpa_cmd_in = fpa_in) = 1
    ) ;
  ) ;

  (* |===| Guide 120, stable version. *)
  @mode g120_130_stable (
    @require count_succ_true(fpa_eng_in) >= 2 ;
    @require count_succ_true(fpa_cmd_in = fpa_in) >= 2 ;
    @require cmd_stable ;
    @ensure (
      pitch_cmd_out = pitch_in
      -- ( (next_fpa < fpa_cmd_in) and (pitch > fpa_cmd_in) ) or
      -- ( (next_fpa > fpa_cmd_in) and (pitch < fpa_cmd_in) ) or
      -- duration(true) < 3
    ) ;
  ) ;
*)

var
	DynamicSaturation_1_1 : real;
	KIgamerr_1_1 : real;
	Kgamerr_1_1 : real;
	LogicalOperator_1_1 : bool;
	Mux_1_1 : real; Mux_1_2 : real;
	Mux1_1_1 : real; Mux1_1_2 : real;
	Product1_1_1 : real;
	Sum_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	hddLim1_1_1 : real;
	hddLim2_1_1 : real;
	hddLimProduct_1_1 : real;
	integrator_reset_1_1 : real;
	kt2fps_1_1 : real;
	m1_1_1 : real;
let 
	DynamicSaturation_1_1 = LONGITUDINAL_CONTROLLER_FPAControl_DynamicSaturation(Product1_1_1, KIgamerr_1_1, m1_1_1);
	KIgamerr_1_1 = 1.0000000000 * Sum2_1_1 ;
	Kgamerr_1_1 = 1.4000000000 * gamma_1_1;
	LogicalOperator_1_1 = not engage_1_1;
	Mux_1_1 = gamcmd_1_1 ;
	Mux_1_2 = gamma_1_1 ;
	Mux1_1_1 = Sum2_1_1 ;
	Mux1_1_2 = DynamicSaturation_1_1 ;
  -- Original code, actually linear {
  --   hddLim1_1_1 = 4.8300000000;
  --   hddLim2_1_1 = 57.2958000000;
  --   hddLimProduct_1_1 = hddLim1_1_1 * hddLim2_1_1;
	--   Product1_1_1 = hddLimProduct_1_1 * kt2fps_1_1;
  -- }
  -- Abstraction, useless as it's linear {
  --   hddLim1_1_1 = 4.8300000000;
  --   hddLim2_1_1 = 57.2958000000;
  --   hddLimProduct_1_1 = times(hddLim1_1_1, hddLim2_1_1) ;
	--   Product1_1_1 = times(hddLimProduct_1_1, kt2fps_1_1) ;
  -- }
  -- Instead we just do {
  Product1_1_1 = (4.83 * 57.2958) * kt2fps_1_1 ;
  -- }
	Sum_1_1 = thetadeg_1_1 + Kgamerr_1_1;
	Sum1_1_1 = integrator_reset_1_1 - Kgamerr_1_1;
	Sum2_1_1 = gamcmd_1_1 - gamma_1_1;
	integrator_reset_1_1 = LONGITUDINAL_CONTROLLER_FPAControl_integrator_reset(DynamicSaturation_1_1, LogicalOperator_1_1, Sum_1_1);
	kt2fps_1_1 = 1.6878000000 * VT_1_1;
	m1_1_1 = -1.0000000000 * Product1_1_1;
	PitchCmd_1_1 = Sum1_1_1;
tel

node LONGITUDINAL_CONTROLLER_EngageORzero (Engage_1_1 : bool; In_1_1 : real; )
returns (Out_1_1 : real) ;
var
	LogicalOperator5_1_1 : bool;
	Switch1_1_1 : real;
	zero10_1_1 : real;
	zero9_1_1 : real;
let 
	LogicalOperator5_1_1 = Engage_1_1 and (if zero10_1_1 = 0.0 then false else true);
	Switch1_1_1 = if (if LogicalOperator5_1_1 then 1.0 else 0.0) >= 0.5000000000 then In_1_1 else zero9_1_1;
	zero10_1_1 = 1.0000000000;
	zero9_1_1 = 0.0000000000;
	Out_1_1 = Switch1_1_1;
tel

node LONGITUDINAL_CONTROLLER_AltitudeControl_VariableLimitSaturation (up_lim_1_1 : real; SigIn_1_1 : real; Lo_lim_1_1 : real; )
returns (Out1_1_1 : real) ;
var
	Enforcelowlim_1_1 : real;
	Enforceuplim_1_1 : real;
let 
	Enforcelowlim_1_1 = if Lo_lim_1_1 >= SigIn_1_1 then Lo_lim_1_1 else SigIn_1_1;
	Enforceuplim_1_1 = if Enforcelowlim_1_1 <= up_lim_1_1 then Enforcelowlim_1_1 else up_lim_1_1;
	Out1_1_1 = Enforceuplim_1_1;
tel

node LONGITUDINAL_CONTROLLER_AltitudeControl_VariableRateLimit_VariableLimitSaturation (up_lim_1_1 : real; SigIn_1_1 : real; Lo_lim_1_1 : real; )
returns (Out1_1_1 : real) ;
var
	Enforcelowlim_1_1 : real;
	Enforceuplim_1_1 : real;
let 
	Enforcelowlim_1_1 = if Lo_lim_1_1 >= SigIn_1_1 then Lo_lim_1_1 else SigIn_1_1;
	Enforceuplim_1_1 = if Enforcelowlim_1_1 <= up_lim_1_1 then Enforcelowlim_1_1 else up_lim_1_1;
	Out1_1_1 = Enforceuplim_1_1;
tel

node LONGITUDINAL_CONTROLLER_AltitudeControl_VariableRateLimit (ratelim_1_1 : real; input_1_1 : real; ICtrig_1_1 : bool; IC_1_1 : real; )
returns (output_1_1 : real) ;

(* This holds. *)
(*
--@var clamped = clamp(
  -ratelim_1_1, 20.0 * (input_1_1 - output_1_1), ratelim_1_1
) ;

--@require ratelim_1_1 = 3.2 ;
--@require ICtrig_1_1 => input_1_1 = 0.0 ;

--@mode no_ic_trig ;
--@require not ICtrig_1_1 ;

--@mode ic_trig_init ;
--@require ICtrig_1_1 and (true -> not pre ICtrig_1_1) ;

--@mode ic_trig ;
--@require false -> ICtrig_1_1 and pre ICtrig_1_1 ;
--@ensure true -> duration(true) >= 3 => output_1_1 <=  3.2 + pre IC_1_1 ;
--@ensure true -> duration(true) >= 3 => output_1_1 >= -3.2 + pre IC_1_1 ;
--@ensure true -> (
  (duration(true) = 2 and pre ICtrig_1_1) => output_1_1 = 2.0 * pre IC_1_1
) ;
*)

var
	Gain_1_1 : real;
	Gain1_1_1 : real;
	Sum2_1_1 : real;
	VariableLimitSaturation_1_1 : real;
	integrator_reset_Add_1_1 : real;
	integrator_reset_Constant_1_1 : real;
	integrator_reset_Gain1Reset_1_1 : real;
	integrator_reset_Product_1_1 : real;
	integrator_reset_Product1_1_1 : real;
	integrator_reset_Product2_1_1 : real;
	integrator_reset_Sum1_1_1 : real;
	integrator_reset_Sum2Reset_1_1 : real;
	integrator_reset_Sum3_1_1 : real;
	integrator_reset_Sum4_1_1 : real;
	integrator_reset_delay_sharp_1_1_1 : real;
	integrator_reset_delay_sharp_2_1_1 : real;
	integrator_reset_delay_sharp_3_1_1 : bool;
	integrator_reset_eq0_1_1 : bool;
	integrator_reset_ne0_1_1 : bool;
	integrator_reset_ne1_1_1 : bool;
	integrator_reset_zero_1_1 : real;
let 
	Gain_1_1 = 20.0000000000 * Sum2_1_1;
	Gain1_1_1 = -1.0000000000 * ratelim_1_1;
	Sum2_1_1 = input_1_1 - integrator_reset_delay_sharp_2_1_1;
	VariableLimitSaturation_1_1 = LONGITUDINAL_CONTROLLER_AltitudeControl_VariableRateLimit_VariableLimitSaturation(ratelim_1_1, Gain_1_1, Gain1_1_1);
	integrator_reset_Add_1_1 = integrator_reset_Product1_1_1 + integrator_reset_Product2_1_1;
	integrator_reset_Constant_1_1 = 0.0000000000;
	integrator_reset_Gain1Reset_1_1 = 1.0000000000 * VariableLimitSaturation_1_1;
	-- integrator_reset_Product_1_1 = IC_1_1 * integrator_reset_delay_sharp_1_1_1;
  integrator_reset_Product_1_1 = IC_1_1 -> 0.0 ;
	-- integrator_reset_Product1_1_1 = integrator_reset_Sum3_1_1 * (if integrator_reset_ne0_1_1 then 1.0 else 0.0);
	integrator_reset_Product1_1_1 =
		if integrator_reset_ne0_1_1 then integrator_reset_Sum3_1_1 else 0.0 ;
	-- integrator_reset_Product2_1_1 = (if integrator_reset_eq0_1_1 then 1.0 else 0.0) * integrator_reset_Sum3_1_1 * (if integrator_reset_ne1_1_1 then 1.0 else 0.0);
	integrator_reset_Product2_1_1 =
		if integrator_reset_eq0_1_1 and integrator_reset_ne1_1_1
		then integrator_reset_Sum3_1_1 else 0.0 ;
	integrator_reset_Sum1_1_1 = integrator_reset_Gain1Reset_1_1 + integrator_reset_Sum2Reset_1_1;
	integrator_reset_Sum2Reset_1_1 = integrator_reset_Sum4_1_1 + integrator_reset_Product_1_1;
	integrator_reset_Sum3_1_1 =  - integrator_reset_delay_sharp_2_1_1 + IC_1_1;
	integrator_reset_Sum4_1_1 = integrator_reset_delay_sharp_2_1_1 + integrator_reset_Add_1_1;
	integrator_reset_delay_sharp_1_1_1 = 1.0000000000 -> pre integrator_reset_Constant_1_1;
	integrator_reset_delay_sharp_2_1_1 = 0.0000000000 -> pre integrator_reset_Sum1_1_1;
	integrator_reset_delay_sharp_3_1_1 = false -> pre ICtrig_1_1;
	integrator_reset_eq0_1_1 = (if ICtrig_1_1 then 1.0 else 0.0) = integrator_reset_zero_1_1;
	integrator_reset_ne0_1_1 = not((if ICtrig_1_1 then 1.0 else 0.0) = integrator_reset_zero_1_1);
	integrator_reset_ne1_1_1 = not((if integrator_reset_delay_sharp_3_1_1 then 1.0 else 0.0) = integrator_reset_zero_1_1);
	integrator_reset_zero_1_1 = 0.0000000000;
	output_1_1 = integrator_reset_delay_sharp_2_1_1;
tel

node LONGITUDINAL_CONTROLLER_AltitudeControl_Saturation1 (SigIn_1_1 : real; )
returns (Out1_1_1 : real) ;
var
	Constant1_1_1 : real;
	Constant2_1_1 : real;
	Enforcelowlim_1_1 : real;
	Enforceuplim_1_1 : real;
let 
	Constant1_1_1 = 0.0001000000;
	Constant2_1_1 = 1000.0000000000;
	Enforcelowlim_1_1 = if Constant1_1_1 >= SigIn_1_1 then Constant1_1_1 else SigIn_1_1;
	Enforceuplim_1_1 = if Enforcelowlim_1_1 <= Constant2_1_1 then Enforcelowlim_1_1 else Constant2_1_1;
	Out1_1_1 = Enforceuplim_1_1;
tel

node LONGITUDINAL_CONTROLLER_AltitudeControl (engage_1_1 : bool; AltCmd_1_1 : real; Altitude_1_1 : real; gskts_1_1 : real; hdot_1_1 : real; )
returns (altgamcmd_1_1 : real) ;

(*@contract

  var engaged_in = engage_1_1 ;
  var alt_cmd_in = AltCmd_1_1 ;
  var alt_in = Altitude_1_1 ;
  var gskts_in = gskts_1_1 ;
  var hdot_in = hdot_1_1 ;

  var alt_cmd_out = altgamcmd_1_1 ;

  -- @require alt_cmd_in = 0.0 -> true ;
  -- @require alt_in = 0.0 -> true ;
  -- @require gskts_in = 0.0 -> true ;
  -- @require alt_cmd_in >= 0.0 ;
  -- @require alt_in >= 0.0 ;
  -- @require gskts_in >= 0.0 ;
  -- @require PseudoContinuous(gskts_in, 1.0) ;
  -- @require PseudoContinuous(alt_cmd_in, 1.0) ;
  @require PseudoContinuous(alt_in, 1.0) ;
  @require PseudoContinuous(hdot_in, 1.0) ;

  @require true -> alt_in = hdot_in + pre alt_in ;

  -- @require not engaged_in -> true ;

  -- @require (not engaged_in) => alt_cmd_in = alt_in ;

  @mode disengaged_slow (
    @require not engaged_in ;
    @require gskts_in < 100.0 ;
  ) ;

  @mode disengaged_fast (
    @require not engaged_in ;
    @require gskts_in >= 100.0 ;
    (* O.34 > 57.2958 / (1.6878 * 100), where 100 is the lower bound of
      gskts_in. *)
    @ensure true -> (
      (pre not engaged_in) => (
        alt_cmd_out <= (3.2 + pre hdot_in) * 0.34
      )
    ) ;
    @ensure true -> (
      (pre not engaged_in) => (
        alt_cmd_out >= (- 3.2 + pre hdot_in) * 0.34
      )
    ) ;
  ) ;

  (* Engaged, unspecified for now. *)
  @mode engaged (
    @require engaged_in ;
  ) ;
*)

var
	Abs_1_1 : real;
	Constant1_1_1 : real;
	Constant3_1_1 : real;
	Constant4_1_1 : real;
	Divide_1_1 : real;
	Kh_1_1 : real;
	LogicalOperator_1_1 : bool;
	Mux_1_1 : real; Mux_1_2 : real;
	Mux1_1_1 : real; Mux1_1_2 : real;
	Saturation1_1_1 : real;
	Sum_1_1 : real;
	Sum3_1_1 : real;
	Switch_1_1 : real;
	VariableRateLimit_1_1 : real;
	VariableLimitSaturation_1_1 : real;
	k_1_1 : real;
	kts2fps_1_1 : real;
	r2d_1_1 : real;
let 
	Abs_1_1 = if hdot_1_1 >= 0.0 then hdot_1_1 else -hdot_1_1;
	Constant1_1_1 = 0.0000000000;
	Constant3_1_1 = 10.0000000000;
	Constant4_1_1 = 3.2000000000;
  -- Divide_1_1 = VariableRateLimit_1_1 / Saturation1_1_1;
  -- Divide_1_1 = temporal_divid(VariableRateLimit_1_1, Saturation1_1_1);
	-- Divide_1_1 = divid_fun(VariableRateLimit_1_1, Saturation1_1_1);
  Divide_1_1 = if gskts_1_1 >= 100.0 then divid_bounded_num(
    VariableRateLimit_1_1,
    if gskts_1_1 < 100.0 then 200.0 else Saturation1_1_1,
    168.78,
    1000.0
  ) else divid_bounded_num(
    VariableRateLimit_1_1, Saturation1_1_1, 0.0001, 1000.0
  ) ;
	Kh_1_1 = 0.0800000000 * Sum_1_1;
	LogicalOperator_1_1 = not engage_1_1;
	Mux_1_1 = AltCmd_1_1 ;
	Mux_1_2 = Altitude_1_1 ;
	Mux1_1_1 = VariableLimitSaturation_1_1 ;
	Mux1_1_2 = VariableRateLimit_1_1 ;
	Saturation1_1_1 = LONGITUDINAL_CONTROLLER_AltitudeControl_Saturation1(kts2fps_1_1);
	Sum_1_1 = AltCmd_1_1 - Altitude_1_1;
	Sum3_1_1 = Abs_1_1 + Constant3_1_1;
  (* |===| Bug, >= should be >. *)
  -- Switch_1_1 = if (if engage_1_1 then 1.0 else 0.0) >= 0.0000000000 then Kh_1_1 else Constant1_1_1;
	Switch_1_1 = if engage_1_1 then Kh_1_1 else Constant1_1_1 ;
	VariableRateLimit_1_1 = LONGITUDINAL_CONTROLLER_AltitudeControl_VariableRateLimit(Constant4_1_1, VariableLimitSaturation_1_1, LogicalOperator_1_1, hdot_1_1);
	VariableLimitSaturation_1_1 = LONGITUDINAL_CONTROLLER_AltitudeControl_VariableLimitSaturation(Sum3_1_1, Switch_1_1, k_1_1);
	k_1_1 = -1.0000000000 * Sum3_1_1;
	kts2fps_1_1 = 1.6878000000 * gskts_1_1;
	r2d_1_1 = 57.2958000000 * Divide_1_1;
	altgamcmd_1_1 = r2d_1_1;
tel

node LONGITUDINAL_CONTROLLER (FPACmd_1_1 : real; AltEng_1_1 : bool; FpaEng_1_1 : bool; AltCmd_1_1 : real; Alt_1_1 : real; thetaDeg_1_1 : real; qDeg_1_1 : real; GsKts_1_1 : real; hdot_1_1 : real; VT_1_1 : real; Gamma_1_1 : real; CAS_1_1 : real; ElevStick_1_1 : real; )
returns (alt_cmd_out, pitch_cmd_out, ElevCmd_1_1 : real) ;

(*@contract

  (* # Ghost vars. *)


  (* ## Inputs. *)

  (* Altitude engaged flag. *)
  var alt_eng_in = AltEng_1_1 ;
  (* Altitude command. *)
  var alt_cmd_in = AltCmd_1_1 ;
  (* Altitude. *)
  var alt_in = Alt_1_1 ;
  (* Derivative of the altitude. *)
  var hdot_in = hdot_1_1 ;

  (* FPA engaged flag. *)
  var fpa_eng_in = FpaEng_1_1 ;
  (* Actual pitch (theta). *)
  var pitch_in = thetaDeg_1_1 ;
  (* FPA command. *)
  var fpa_cmd_in = FPACmd_1_1 ;
  var pre_fpa_cmd_in = fpa_cmd_in -> pre fpa_cmd_in ;
  (* Actual FPA. *)
  var fpa_in = Gamma_1_1 ;

  (* Ground speed in knots. *)
  var gskts_in = GsKts_1_1 ;
  (* Speed of the aircraft. *)
  var speed_in = VT_1_1 ;
  (* Calibrated Airspeed. *)
  var cas_in = CAS_1_1 ;

  (* Elevation stick. *)
  var elev_stick_in = ElevStick_1_1 ;

  (* Something. *)
  var qdeg = qDeg_1_1 ;


  (* ## Output. *)

  (* Pitch command. *)
  var elev_cmd_out = ElevCmd_1_1 ;
  var pre_elev_cmd_out = elev_cmd_out -> pre elev_cmd_out ;
  var pre_pitch_cmd_out = pitch_cmd_out -> pre pitch_cmd_out ;


  (* ## Ghost vars. *)

  (* True if the fpa command hasn't changed. *)
  var fpa_cmd_stable = fpa_cmd_in = pre_fpa_cmd_in ;


  var fpa_cmd_delta_lb = 0.0 -> (-3.2 + pre hdot_in) * 0.34 ;
  var fpa_cmd_delta_ub = 0.0 -> ( 3.2 + pre hdot_in) * 0.34 ;
  var fpa_cmd_in_lb = fpa_cmd_in + fpa_cmd_delta_lb ;
  var fpa_cmd_in_ub = fpa_cmd_in + fpa_cmd_delta_ub ;

  -- var pitch_diff_ubound = 4.83 * 57.2958 * 1.6878 * speed_in ;
  -- 
  -- var safe_pitch_diff = (
  --   if fpa_cmd_in - fpa_in > pitch_diff_ubound then pitch_diff_ubound
  --   else if fpa_cmd_in - fpa_in < - pitch_diff_ubound then - pitch_diff_ubound
  --   else fpa_cmd_in - fpa_in
  -- ) ;

  (* Climbing means that the pitch command is above the current pitch, above its
    previous value, or that FPA is expected to reach / go above the FPA command
    in the next step. *)
  var raising = 
    pitch_cmd_out > pitch_in or
    pitch_cmd_out >= pre_pitch_cmd_out or
    fpa_cmd_in_lb <= fpa_in + (0.0 -> fpa_in - pre fpa_in) ;

  (* Descending means that the pitch command is below the current pitch, below
    its previous value, or that FPA is expected to reach/ go below the FPA
    command in the next step. *)
  var lowering =
    pitch_cmd_out < pitch_in or
    pitch_cmd_out <= pre_pitch_cmd_out or
    fpa_cmd_in_ub >= fpa_in + (0.0 -> fpa_in - pre fpa_in) ;


  (* # Assumptions. *)


  (* All speed inputs are positive. *)
  @require gskts_in >= 0.0 ;
  @require speed_in >= 0.0 ;
  @require cas_in >= 0.0 ;


  (* ## Initial state assumptions. *)

  (* Nothing's engaged in the initial state. *)
  -- @require (not (fpa_eng_in or alt_eng_in)) -> true ;
  (* We start with pitch and FPA at 0. *)
  -- @require fpa_in = 0.0 -> true ;
  -- @require pitch_in = 0.0 -> true ;


  (* ## Pseudo-closed-loop assumptions. *)

  (* Important inputs cannot change too fast. *)
  @require PseudoContinuous(alt_in, 1.0) ;
  @require PseudoContinuous(hdot_in, 1.0) ;
  (* hdot semantics. *)
  @require true -> alt_in = hdot_in + pre alt_in ;

  (* Pitch command is immediate when we're engaged.
    Can't lift this one as we don't have access to the pitch command. *)
  -- @require true -> (
  --   fpa_eng_in and pre fpa_eng_in => pitch_in = pre pitch_cmd_out
  -- ) ;
  (* Super strong relation between pitch and FPA. *)
  -- @require pitch_in = 1.4 * fpa_in ;
  (* Pitch converges towards pitch command.
     Ideally we want this and not the previous one. *)
  @require true -> (
    pre fpa_eng_in => (
      abs(pitch_in - pre_pitch_cmd_out) < pre abs(pitch_in - pitch_cmd_out) or
      (pre pitch_in) = pre_pitch_cmd_out
    )
  ) ;
  (* Link between pitch and FPA. *)
  (* FPA and theta have same sign, and abs(fpa) < (theta). *)
  -- @require (pitch_in = 0.0 => fpa_in = 0.0) ;
  -- @require true -> (
  --   pitch_in > 0.0 => (
  --     pitch_in > fpa_in and fpa_in >= pitch_in / 1.4
  --   )
  -- ) ;
  -- @require true -> (
  --   pitch_in < 0.0 => (
  --     pitch_in / 1.4 >= fpa_in and fpa_in > pitch_in
  --   )
  -- ) ;
  -- (* Derivatives of FPA and pitch have the same sign. *)
  @require true -> (
    ( (pitch_in > pre pitch_in) = (fpa_in > pre fpa_in) ) and
    ( (pitch_in < pre pitch_in) = (fpa_in < pre fpa_in) ) and
    ( (pitch_in = pre pitch_in) = (fpa_in = pre fpa_in) )
  ) ;



  (* ## Engage assumptions. *)

  (* Cannot be engaged if speed is less than 100. *)
  @require (fpa_eng_in or alt_eng_in) => speed_in >= 100.0 ;
  @require (fpa_eng_in or alt_eng_in) => gskts_in >= 100.0 ;
  @require (fpa_eng_in or alt_eng_in) => cas_in   >= 100.0 ;

  (* FPA and Altitude cannot be engaged at the same time. *)
  @require not (fpa_eng_in and alt_eng_in) ;

  @require fall(alt_eng_in) => not fpa_eng_in ;


  @mode whatevs (
    @require true ;
  ) ;

  (* Elevation stick bypasses everything. *)
  @mode manual_override (
    @require elev_stick_in <> 0.0 ;
    @ensure elev_cmd_out = elev_stick_in ;
  ) ;

  @mode alt_engaged (
    @require elev_stick_in = 0.0 ;
    @require cas_in <= 500.0 ;
    @require alt_eng_in ;
  ) ;

  (* When disengaged and there's no manual override output is zero. *)
  @mode disengaged (
    @require elev_stick_in = 0.0 ;
    @require cas_in <= 500.0 ;
    @require not (fpa_eng_in or alt_eng_in) ;
    @ensure elev_cmd_out = 0.0 ;
  ) ;

  (* If CAS is above 500.0 and there's no manual override output is zero. *)
  @mode too_fast (
    @require elev_stick_in = 0.0 ;
    @require cas_in > 500.0 ;
    @ensure elev_cmd_out = 0.0 ;
  ) ;

  -- @mode fpa_deactivated (
  -- @require not fpa_eng_in ;
  -- @ensure true -> (
  --   (has_been_true(fpa_eng_in) and pre not fpa_eng_in) => (
  --     pitch_cmd_out = (
  --       pre (safe_pitch_diff + pitch_in + 1.4 * fpa_in)
  --     ) - 1.4 * fpa_in
  --   )
  -- ) ;

  @mode fpa_engaging (
    @require elev_stick_in = 0.0 ;
    @require cas_in <= 500.0 ;
    @require fpa_eng_in -> rise(fpa_eng_in) ;
  ) ;

  (* |===| Guide 120/130, raising. *)
  @mode fpa_g120_130_raising (
    @require fpa_eng_in ;
    @require cas_in <= 500.0 ;
    @require elev_stick_in = 0.0 ;
    @require false -> pre fpa_eng_in ;
    @require (
      (* (-3.2 + pre hdot_in) * 0.34 is the lower bound on alt_cmd_out when alt
        is not engaged. *)
      fpa_cmd_in_lb > fpa_in
    ) ;
    @ensure (
      (* Not confirmed that we're climbing. *)
      (false -> pre (fpa_cmd_in_lb <= fpa_in)) or
      (* Pitch was at pitch command. *)
      (false -> pre (pitch_in = pitch_cmd_out)) or
      (* Climbing. *)
      raising or
      (* We're not descending but we were in the previous state. *)
      ( not raising and (false -> pre raising) )
    ) ;
  ) ;

  (* |===| Guide 120/130, lowering. *)
  @mode fpa_g120_130_lowering (
    @require fpa_eng_in ;
    @require cas_in <= 500.0 ;
    @require elev_stick_in = 0.0 ;
    @require false -> pre fpa_eng_in ;
    @require (
      (* (+3.2 + pre hdot_in) * 0.34 is the lower bound on alt_cmd_out when alt
        is not engaged. *)
      fpa_cmd_in_ub < fpa_in
    ) ;
    @ensure (
      (* Not confirmed that we're descending. *)
      (false -> pre (fpa_cmd_in_ub >= fpa_in)) or
      (* Pitch was at pitch command. *)
      (false -> pre (pitch_in = pitch_cmd_out)) or
      (* Descending. *)
      lowering or
      (* We're not descending but we were in the previous state. *)
      ( not lowering and (false -> pre lowering) )
    ) ;
  ) ;

  (* |===| Guide 120_130, stabilizing version.
   Things get tricky when we get to the requested FPA.
   Not sure what the ensure should be here. *)
  @mode g120_130_stabilizing (
    @require fpa_eng_in ;
    @require cas_in <= 500.0 ;
    @require elev_stick_in = 0.0 ;
    @require false -> (fpa_cmd_in_lb >= fpa_in) ;
    @require false -> (fpa_cmd_in_ub <= fpa_in) ;
  ) ;
*)

var
	AltitudeControl_1_1 : real;
	EngageORzero_1_1 : real;
	FPAControl_1_1 : real;
	LogicalOperator_1_1 : bool;
	ManualOverride_1_1 : real;
	PitchInnerLoop_1_1 : real;
	Sum7_1_1 : real;
  act_cmd_ge_cmd, alt_out_loc_pos : bool ;
	k2_1_1 : real;
	k5_1_1 : real;
let 
	AltitudeControl_1_1 = LONGITUDINAL_CONTROLLER_AltitudeControl(AltEng_1_1, AltCmd_1_1, Alt_1_1, GsKts_1_1, hdot_1_1);
	EngageORzero_1_1 = LONGITUDINAL_CONTROLLER_EngageORzero(LogicalOperator_1_1, PitchInnerLoop_1_1);
	FPAControl_1_1 = LONGITUDINAL_CONTROLLER_FPAControl(FpaEng_1_1, Sum7_1_1, Gamma_1_1, thetaDeg_1_1, VT_1_1);
	LogicalOperator_1_1 = AltEng_1_1 or FpaEng_1_1;
	ManualOverride_1_1 = LONGITUDINAL_CONTROLLER_ManualOverride(ElevStick_1_1, EngageORzero_1_1);
	PitchInnerLoop_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop(k5_1_1, thetaDeg_1_1, qDeg_1_1, CAS_1_1);
	Sum7_1_1 = FPACmd_1_1 + k2_1_1;
  act_cmd_ge_cmd = Sum7_1_1 >= FPACmd_1_1 ;
  alt_out_loc_pos = k2_1_1 >= 0.0 ;
	k2_1_1 = 1.0000000000 * AltitudeControl_1_1;
	k5_1_1 = 1.0000000000 * FPAControl_1_1;
	ElevCmd_1_1 = ManualOverride_1_1;
  pitch_cmd_out = if act_cmd_ge_cmd or not act_cmd_ge_cmd then
    if alt_out_loc_pos or not alt_out_loc_pos then FPAControl_1_1 else 0.0
    else 0.0 ;
  alt_cmd_out = AltitudeControl_1_1 ;
tel

node Mode_plus_Longitudinal (
	head_mode : real ;
	ail_stick_in : real ;
	elev_stick_in : real ;
  -- Altitude mode.
	alt_mode : real ;
  -- Flight Path Angle mode.
	fpa_mode : real ;
  -- Auto Throttle mode.
	at_mode : real ;
	alt_cmd_in : real ;
	alt_in : real ;
	cas_in : real ;
	cas_cmd : real ;
	pitch_in : real ;
	qbdegf_1_1 : real ;
	gskts_in : real ;
	hdot_in : real ;
	speed_in : real ;
	fpa_in : real ;
	fpa_cmd_in : real ;
) returns (
	head_eng_out, alt_eng_out, at_eng_out, fpa_eng_out : bool ;
	cas_cmd_out, alt_cmd_out, pitch_cmd_out, elev_cmd_out : real ;
) ;

(*@contract

  (* Helpers for component activation. *)
  var alt_eng_in = (alt_mode <> 0.0) ;
  var fpa_eng_in = (fpa_mode <> 0.0) ;
  var head_eng_in = (head_mode <> 0.0) ;
  var deactivate = (ail_stick_in <> 0.0 or elev_stick_in <> 0.0) ;
  var deactivation = false -> pre deactivate ;
  var pre_fpa_cmd_in = fpa_cmd_in -> pre fpa_cmd_in ;

  var pre_elev_cmd_out = elev_cmd_out -> pre elev_cmd_out ;
  var pre_pitch_cmd_out = pitch_cmd_out -> pre pitch_cmd_out ;

  var fpa_cmd_delta_lb = 0.0 -> (-3.2 + pre hdot_in) * 0.34 ;
  var fpa_cmd_delta_ub = 0.0 -> ( 3.2 + pre hdot_in) * 0.34 ;
  var fpa_cmd_in_lb = fpa_cmd_in + fpa_cmd_delta_lb ;
  var fpa_cmd_in_ub = fpa_cmd_in + fpa_cmd_delta_ub ;

  (* When CAS is greater than 500 FPA and Altitude mode output 0. *)
  var going_too_fast = cas_in > 500.0 ;

  (* Climbing means that the pitch command is above the current pitch, above
    its previous value, or that FPA is expected to reach / go above the FPA
    command in the next step. *)
  var raising = 
    pitch_cmd_out > pitch_in or
    pitch_cmd_out >= pre_pitch_cmd_out or
    fpa_cmd_in_lb <= fpa_in + (0.0 -> fpa_in - pre fpa_in) ;

  (* Descending means that the pitch command is below the current pitch, below
    its previous value, or that FPA is expected to reach/ go below the FPA
    command in the next step. *)
  var lowering =
    pitch_cmd_out < pitch_in or
    pitch_cmd_out <= pre_pitch_cmd_out or
    fpa_cmd_in_ub >= fpa_in + (0.0 -> fpa_in - pre fpa_in) ;

  (* Alt requested and no deactivation since then. *)
  var alt_requested =
    has_been_true_reset(alt_eng_in, deactivation and not alt_eng_in) ;
  (* FPA requested and no deactivation since then. *)
  var fpa_requested =
    has_been_true_reset(fpa_eng_in, deactivation and not fpa_eng_in) ;
  (* Head requested and no deactivation since then. *)
  var head_requested =
    has_been_true_reset(head_eng_in, deactivation and not head_eng_in) ;

  (* Separates Guide 210 (not far_altitude_gap) from Guide 170/180
    (far_altitude_gap). In the former Alt has priority, while in the latter
    it's FPA. *)
  var far_altitude_gap = abs(alt_in - alt_cmd_in) > 200.0 ;

  (* See "MODE_LOGIC_HeadingMode" for an explanation of the following. *)
  @require true ->
    (since(head_eng_in) = 1) => (pre since(not head_eng_in) > 1) ;
  @require true ->
    (since(not head_eng_in) = 1) => (pre since(head_eng_in) > 1) ;
  (* See "MODE_LOGIC_AltAndFPAMode" for an explanation of the following. *)
  @require true ->
    (since(alt_eng_in) = 1) => (pre since(not alt_eng_in) > 1) ;
  @require true ->
    (since(not alt_eng_in) = 1) => (pre since(alt_eng_in) > 1) ;
  @require true ->
    (since(fpa_eng_in) = 1) => (pre since(not fpa_eng_in) > 1) ;
  @require true ->
    (since(not fpa_eng_in) = 1) => (pre since(fpa_eng_in) > 1) ;
  @require true ->
    (since(deactivate) = 1) => (pre since(not deactivate) > 1) ;
  @require true ->
    (since(not deactivate) = 1) => (pre since(deactivate) > 1) ;

  (* System does not behave well when an input and deactivate fall at the same
    time. *)
  @require fall(alt_eng_in) => not fall(deactivate) ;
  @require fall(fpa_eng_in) => not fall(deactivate) ;
  (* System does not behave well when an input and deactivate fall at the same
    time. *)
  @require fall(head_eng_in) => not fall(deactivate) ;

  @require alt_in >= 0.0 ;
  @require alt_cmd_in >= 0.0 ;
  @require fpa_cmd_in >= 0.0 ;

  @require PseudoContinuous(alt_in, 1.0) ;
  @require PseudoContinuous(hdot_in, 1.0) ;

  (* hdot semantics. *)
  @require true -> alt_in = hdot_in + pre alt_in ;

  (* All speed inputs are positive. *)
  @require gskts_in >= 0.0 ;
  @require speed_in >= 0.0 ;
  @require cas_in >= 0.0 ;

  (* Pitch converges towards pitch command. *)
  @require true -> (
    pre fpa_eng_out => (
      abs(pitch_in - pre_pitch_cmd_out) < pre abs(pitch_in - pitch_cmd_out) or
      (pre pitch_in) = pre_pitch_cmd_out
    )
  ) ;

  (* Link between pitch and FPA. *)
  (* FPA and theta have same sign, and abs(fpa) < (theta). *)
  -- @require (pitch_in = 0.0 => fpa_in = 0.0) ;
  -- @require true -> (
  --   pitch_in > 0.0 => (
  --     pitch_in > fpa_in and fpa_in >= pitch_in / 1.4
  --   )
  -- ) ;
  -- @require true -> (
  --   pitch_in < 0.0 => (
  --     pitch_in / 1.4 >= fpa_in and fpa_in > pitch_in
  --   )
  -- ) ;
  (* Derivatives of FPA and pitch have the same sign. *)
  @require true -> (
    ( (pitch_in > pre pitch_in) = (fpa_in > pre fpa_in) ) and
    ( (pitch_in < pre pitch_in) = (fpa_in < pre fpa_in) ) and
    ( (pitch_in = pre pitch_in) = (fpa_in = pre fpa_in) )
  ) ;



  (* ## Engage assumptions. *)

  (* Cannot be engaged if speed is less than 100. *)
  @require (fpa_eng_out or alt_eng_out) => speed_in >= 100.0 ;
  @require (fpa_eng_out or alt_eng_out) => gskts_in >= 100.0 ;
  @require (fpa_eng_out or alt_eng_out) => cas_in   >= 100.0 ;

  @require fall(alt_eng_out) => not fpa_eng_out ;

  (* Whatever happens, altitude control and FPA control can't be active at the
    same time. *)
  @ensure not (alt_eng_out and fpa_eng_out) ;


  @mode inactive (
    @require duration(not (alt_eng_in or fpa_eng_in or head_eng_in)) > 0 ;
    @ensure not (alt_eng_out or fpa_eng_out or head_eng_in) ;
  ) ;

  (* When deactivated no one is active. *)
  @mode deactivated (
    (* No collision with inactive mode. *)
    @require not inactive ;
    @require not alt_requested ;
    @require not fpa_requested ;
    @require not head_requested ;
    @ensure not (alt_eng_out or fpa_eng_out or head_eng_out) ;
  ) ;

  (* |===| Guide 170.
    Alt does not have priority. It cannot be active if FPA was requested since
    the beginning / last deactivation, or if a deactivation happened since the
    last request for Alt. *)
  @mode guide_170_alt (
    @require far_altitude_gap ;
    @require alt_requested ;
    @require not fpa_requested ;
    @ensure alt_eng_out ;
  ) ;

  (* |===| Guide 180.
    FPA has priority. It is active if no deactivation happened since the last
    FPA request. *)
  @mode guide_180_fpa (
    @require far_altitude_gap ;
    @require fpa_requested ;
    @ensure fpa_eng_out ;
  ) ;

  (* |===| Guide 210, Alt mode.
    Alt has priority. It is active if no deactivation happened since the last
    Alt request. *)
  @mode guide_210_alt (
    @require not far_altitude_gap ;
    @require alt_requested ;
    @ensure alt_eng_out ;
  ) ;

  (* |===| Guide 210, FPA mode.
    FPA does not have priority. It cannot be active if Alt was requested since
    the beginning / last deactivation, or if a deactivation happened since the
    last request for FPA. *)
  @mode guide_210_fpa (
    @require not far_altitude_gap ;
    @require fpa_requested ;
    @require not alt_requested ;
    @ensure fpa_eng_out ;
  ) ;

  (* Altitude and FPA modes cannot be engaged outside of the spec. *)
  @mode alt_and_fpa_inactive (
    (* No intersection with deactivated. *)
    @require not deactivated ;
    @require not (
      guide_170_alt or guide_180_fpa or guide_210_alt or guide_210_fpa
    ) ;
    @ensure not (fpa_eng_out or alt_eng_out) ;
  ) ;

  (* |===| Guide 250. *)
  @mode guide_250 (
    @require head_requested ;
    @ensure head_eng_out ;
  ) ;



  (* ## Modes for FPA / Altitude modes. *)


  (* Elevation stick bypasses everything. *)
  @mode manual_override (
    @require elev_stick_in <> 0.0 ;
    @ensure elev_cmd_out = elev_stick_in ;
  ) ;

  (* When disengaged and there's no manual override output is zero. *)
  @mode disengaged (
    @require not (
      guide_170_alt or guide_180_fpa or guide_210_alt or guide_210_fpa
    ) ;
    @require not manual_override ;
    @ensure elev_cmd_out = 0.0 ;
  ) ;

  (* If CAS is above 500.0 and there's no manual override output of
    longitudinal mode is zero. *)
  @mode too_fast (
    @require not manual_override ;
    @require not disengaged ;
    @require going_too_fast ;
    @ensure elev_cmd_out = 0.0 ;
  ) ;

  @mode fpa_engaging (
    @require not manual_override ;
    @require not going_too_fast ;
    @require (guide_180_fpa or guide_210_fpa) -> rise(
      guide_180_fpa or guide_210_fpa
    ) ;
  ) ;

  (* |===| Guide 120/130, raising. *)
  @mode fpa_g120_130_raising (
    @require not manual_override ;
    @require not going_too_fast ;
    @require guide_180_fpa or guide_210_fpa ;
    @require false -> pre (guide_180_fpa or guide_210_fpa) ;
    @require false -> (
      (* (-3.2 + pre hdot_in) * 0.34 is the lower bound on alt_cmd_out when alt
        is not engaged. *)
      fpa_cmd_in_lb > fpa_in
    ) ;
    @ensure (
      (* Not confirmed that we're climbing. *)
      (false -> pre (fpa_cmd_in_lb <= fpa_in)) or
      (* Pitch was at pitch command. *)
      (false -> pre (pitch_in = pitch_cmd_out)) or
      (* Climbing. *)
      raising or
      (* We're not climbing but we were in the previous state. *)
      ( not raising and (false -> pre raising) )
    ) ;
  ) ;

  (* |===| Guide 120/130, lowering. *)
  @mode fpa_g120_130_lowering (
    @require not manual_override ;
    @require not going_too_fast ;
    @require guide_180_fpa or guide_210_fpa ;
    @require false -> pre (guide_180_fpa or guide_210_fpa) ;
    @require false -> (
      (* (+3.2 + pre hdot_in) * 0.34 is the lower bound on alt_cmd_out when alt
        is not engaged. *)
      fpa_cmd_in_ub < fpa_in
    ) ;
    @ensure (
      (* Not confirmed that we're descending. *)
      (false -> pre (fpa_cmd_in_ub >= fpa_in)) or
      (* Pitch was at pitch command. *)
      (false -> pre (pitch_in = pitch_cmd_out)) or
      (* Descending. *)
      lowering or
      (* We're not descending but we were in the previous state. *)
      ( not lowering and (false -> pre lowering) )
    ) ;
  ) ;

  (* |===| Guide 120_130, stabilizing version.
    Things get tricky when we get to the requested FPA.
    Not sure what the ensure should be here. *)
  @mode g120_130_stabilizing (
    @require not manual_override ;
    @require not going_too_fast ;
    @require guide_180_fpa or guide_210_fpa ;
    @require false -> (fpa_cmd_in_lb >= fpa_in) ;
    @require false -> (fpa_cmd_in_ub <= fpa_in) ;
  ) ;

*)

let 
	(
		head_eng_out,
	  alt_eng_out,
	  fpa_eng_out,
	  at_eng_out,
	  cas_cmd_out
  ) = MODE_LOGIC(
  	head_mode,
  	ail_stick_in,
  	elev_stick_in,
  	alt_mode,
  	fpa_mode,
  	at_mode,
  	alt_cmd_in,
  	alt_in,
  	cas_in,
  	cas_cmd
	);

	(alt_cmd_out, pitch_cmd_out, elev_cmd_out) = LONGITUDINAL_CONTROLLER(
		fpa_cmd_in,
		alt_eng_out,
		fpa_eng_out,
		alt_cmd_in,
		alt_in,
		pitch_in,
		qbdegf_1_1,
		gskts_in,
		hdot_in,
		speed_in,
		fpa_in,
		cas_in,
		elev_stick_in
	);

tel

