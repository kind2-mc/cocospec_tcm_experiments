-- This file has been generated by CocoSim compiler + verifier

include "helpers.lus"

-- System nodes
node MODE_LOGIC_SpeedMode (Actiavte_1_1 : real; Deactivate_1_1 : real; AltEng_1_1 : bool; CAS_1_1 : real; CASCmdMCP_1_1 : real; )
returns (ATEng_1_1 : bool;
	CASCmd_2_1 : real) ;
var
	Add_1_1 : int;
	CompareToConstant_1_1 : bool;
	CompareToConstant1_1_1 : bool;
	LogicalOperator_1_1 : bool;
	LogicalOperator2_1_1 : bool;
	Switch_1_1 : real;
	Switch1_1_1 : real;
	SRFlipFlopRepl_dot__LogicalOperator_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator1_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator2_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator3_1_1 : bool;
	SRFlipFlopRepl_dot__UnitDelay_1_1 : bool;
	SRFlipFlopRepl_dot__UnitDelay1_1_1 : bool;
	UnitDelay2_1_1 : real;
let 
	Add_1_1 = (if CompareToConstant1_1_1 then 1 else 0) + (if LogicalOperator_1_1 then 1 else 0);
	CompareToConstant_1_1 = not(Deactivate_1_1 = 0.0000000000);
	CompareToConstant1_1_1 = not(Actiavte_1_1 = 0.0000000000);
	LogicalOperator_1_1 = AltEng_1_1 and SRFlipFlopRepl_dot__LogicalOperator_1_1;
	LogicalOperator2_1_1 = CompareToConstant1_1_1 or LogicalOperator_1_1;
	Switch_1_1 = if Add_1_1 >= 0 then UnitDelay2_1_1 else Switch1_1_1;
	Switch1_1_1 = if Add_1_1 > 1 then CASCmdMCP_1_1 else CAS_1_1;
	SRFlipFlopRepl_dot__LogicalOperator_1_1 = not(SRFlipFlopRepl_dot__UnitDelay_1_1 and SRFlipFlopRepl_dot__LogicalOperator3_1_1);
	SRFlipFlopRepl_dot__LogicalOperator1_1_1 = not(SRFlipFlopRepl_dot__LogicalOperator2_1_1 and SRFlipFlopRepl_dot__UnitDelay1_1_1);
	SRFlipFlopRepl_dot__LogicalOperator2_1_1 = not LogicalOperator2_1_1;
	SRFlipFlopRepl_dot__LogicalOperator3_1_1 = not CompareToConstant_1_1;
	SRFlipFlopRepl_dot__UnitDelay_1_1 = false -> pre SRFlipFlopRepl_dot__LogicalOperator1_1_1;
	SRFlipFlopRepl_dot__UnitDelay1_1_1 = true -> pre SRFlipFlopRepl_dot__LogicalOperator_1_1;
	UnitDelay2_1_1 = 0.0000000000 -> pre Switch_1_1;
	ATEng_1_1 = SRFlipFlopRepl_dot__LogicalOperator1_1_1;
	CASCmd_2_1 = UnitDelay2_1_1;
tel

node MODE_LOGIC_HeadingMode (
  Actiavte_1_1 : real; Deactivate_1_1 : bool
) returns (HeadEng_1_1 : bool) ;

var
	CompareToConstant_1_1 : bool;
	CompareToConstant1_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator1_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator2_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator3_1_1 : bool;
	SRFlipFlopRepl_dot__UnitDelay_1_1 : bool;
	SRFlipFlopRepl_dot__UnitDelay1_1_1 : bool;
let 
	CompareToConstant_1_1 = not((if Deactivate_1_1 then 1.0 else 0.0) = 0.0000000000);
	CompareToConstant1_1_1 = not(Actiavte_1_1 = 0.0000000000);
	SRFlipFlopRepl_dot__LogicalOperator_1_1 = not(SRFlipFlopRepl_dot__UnitDelay_1_1 and SRFlipFlopRepl_dot__LogicalOperator3_1_1);
	SRFlipFlopRepl_dot__LogicalOperator1_1_1 = not(SRFlipFlopRepl_dot__LogicalOperator2_1_1 and SRFlipFlopRepl_dot__UnitDelay1_1_1);
	SRFlipFlopRepl_dot__LogicalOperator2_1_1 = not CompareToConstant1_1_1;
	SRFlipFlopRepl_dot__LogicalOperator3_1_1 = not CompareToConstant_1_1;
	SRFlipFlopRepl_dot__UnitDelay_1_1 = false -> pre SRFlipFlopRepl_dot__LogicalOperator1_1_1;
	SRFlipFlopRepl_dot__UnitDelay1_1_1 = true -> pre SRFlipFlopRepl_dot__LogicalOperator_1_1;
	HeadEng_1_1 = SRFlipFlopRepl_dot__LogicalOperator1_1_1;
tel

node MODE_LOGIC_AltAndFPAMode (
  ActiavteFPA_1_1 : real; Deactivate_1_1 : bool;
  Altitude_1_1, AltCmd_1_1, ActiavteAlt_1_1 : real
) returns (
  AltEng_1_1 : bool; FPAEng_2_1 : bool
) ;


var
	Abs_1_1 : real;
	Add_1_1 : real;
	CompareToConstant_1_1 : bool;
	CompareToConstant1_1_1 : bool;
	CompareToConstant2_1_1 : bool;
	CompareToConstant3_1_1 : bool;
	LogicalOperator1_1_1 : bool;
	LogicalOperator2_1_1 : bool;
	LogicalOperator3_1_1 : bool;
	LogicalOperator4_1_1 : bool;
	LogicalOperator6_1_1 : bool;
	SRFlipFlopRepl_dot_1_LogicalOperator_1_1 : bool;
	SRFlipFlopRepl_dot_1_LogicalOperator1_1_1 : bool;
	SRFlipFlopRepl_dot_1_LogicalOperator2_1_1 : bool;
	SRFlipFlopRepl_dot_1_LogicalOperator3_1_1 : bool;
	SRFlipFlopRepl_dot_1_UnitDelay_1_1 : bool;
	SRFlipFlopRepl_dot_1_UnitDelay1_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator1_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator2_1_1 : bool;
	SRFlipFlopRepl_dot__LogicalOperator3_1_1 : bool;
	SRFlipFlopRepl_dot__UnitDelay_1_1 : bool;
	SRFlipFlopRepl_dot__UnitDelay1_1_1 : bool;
let 
	Abs_1_1 = if Add_1_1 >= 0.0 then Add_1_1 else -Add_1_1;
	Add_1_1 = Altitude_1_1 - AltCmd_1_1;
	CompareToConstant_1_1 = not((if Deactivate_1_1 then 1.0 else 0.0) = 0.0000000000);
	CompareToConstant1_1_1 = not(ActiavteFPA_1_1 = 0.0000000000);
	CompareToConstant2_1_1 = Abs_1_1 <= 200.0000000000;
	CompareToConstant3_1_1 = not(ActiavteAlt_1_1 = 0.0000000000);
	LogicalOperator1_1_1 = LogicalOperator2_1_1 or CompareToConstant2_1_1;
	LogicalOperator2_1_1 = not SRFlipFlopRepl_dot__LogicalOperator1_1_1;
	LogicalOperator3_1_1 = SRFlipFlopRepl_dot__LogicalOperator1_1_1 and LogicalOperator6_1_1;
	LogicalOperator4_1_1 = SRFlipFlopRepl_dot_1_LogicalOperator1_1_1 and LogicalOperator1_1_1;
	LogicalOperator6_1_1 = not(SRFlipFlopRepl_dot_1_LogicalOperator1_1_1 and CompareToConstant2_1_1);
	SRFlipFlopRepl_dot_1_LogicalOperator_1_1 = not(SRFlipFlopRepl_dot_1_UnitDelay_1_1 and SRFlipFlopRepl_dot_1_LogicalOperator3_1_1);
	SRFlipFlopRepl_dot_1_LogicalOperator1_1_1 = not(SRFlipFlopRepl_dot_1_LogicalOperator2_1_1 and SRFlipFlopRepl_dot_1_UnitDelay1_1_1);
	SRFlipFlopRepl_dot_1_LogicalOperator2_1_1 = not CompareToConstant3_1_1;
	SRFlipFlopRepl_dot_1_LogicalOperator3_1_1 = not CompareToConstant_1_1;
	SRFlipFlopRepl_dot_1_UnitDelay_1_1 = false -> pre SRFlipFlopRepl_dot_1_LogicalOperator1_1_1;
	SRFlipFlopRepl_dot_1_UnitDelay1_1_1 = true -> pre SRFlipFlopRepl_dot_1_LogicalOperator_1_1;
	SRFlipFlopRepl_dot__LogicalOperator_1_1 = not(SRFlipFlopRepl_dot__UnitDelay_1_1 and SRFlipFlopRepl_dot__LogicalOperator3_1_1);
	SRFlipFlopRepl_dot__LogicalOperator1_1_1 = not(SRFlipFlopRepl_dot__LogicalOperator2_1_1 and SRFlipFlopRepl_dot__UnitDelay1_1_1);
	SRFlipFlopRepl_dot__LogicalOperator2_1_1 = not CompareToConstant1_1_1;
	SRFlipFlopRepl_dot__LogicalOperator3_1_1 = not CompareToConstant_1_1;
	SRFlipFlopRepl_dot__UnitDelay_1_1 = false -> pre SRFlipFlopRepl_dot__LogicalOperator1_1_1;
	SRFlipFlopRepl_dot__UnitDelay1_1_1 = true -> pre SRFlipFlopRepl_dot__LogicalOperator_1_1;
	AltEng_1_1 = LogicalOperator4_1_1;
	FPAEng_2_1 = LogicalOperator3_1_1;
tel

node MODE_LOGIC (HeadMode_1_1 : real; ailStick_1_1 : real; elevStick_1_1 : real; AltMode_1_1 : real; FPAMode_1_1 : real; ATMode_1_1 : real; AltCmd_1_1 : real; Altitude_1_1 : real; CAS_1_1 : real; CASCmdMCP_1_1 : real; )
returns (HeadEng_1_1 : bool ;
	AltEng_2_1 : bool;
	FPAEng_3_1 : bool;
	ATEng_4_1 : bool;
	CASCmd_5_1 : real) ;

var
	AltAndFPAMode_1_1 : bool; AltAndFPAMode_2_1 : bool;
	CompareToZero_1_1 : bool;
	CompareToZero1_1_1 : bool;
	Constant_1_1 : real;
	HeadingMode_1_1 : bool;
	LogicalOperator_1_1 : bool;
	SpeedMode_1_1 : bool; SpeedMode_2_1 : real;
let 
	(AltAndFPAMode_1_1, AltAndFPAMode_2_1) = MODE_LOGIC_AltAndFPAMode(FPAMode_1_1, LogicalOperator_1_1, Altitude_1_1, AltCmd_1_1, AltMode_1_1);
	CompareToZero_1_1 = not(ailStick_1_1 = 0.0000000000);
	CompareToZero1_1_1 = not(elevStick_1_1 = 0.0000000000);
	Constant_1_1 = 0.0000000000;
	HeadingMode_1_1 = MODE_LOGIC_HeadingMode(HeadMode_1_1, LogicalOperator_1_1);
	LogicalOperator_1_1 = CompareToZero_1_1 or CompareToZero1_1_1;
	(SpeedMode_1_1, SpeedMode_2_1) = MODE_LOGIC_SpeedMode(ATMode_1_1, Constant_1_1, AltAndFPAMode_2_1, CAS_1_1, CASCmdMCP_1_1);
	HeadEng_1_1 = HeadingMode_1_1;
	AltEng_2_1 = AltAndFPAMode_1_1;
	FPAEng_3_1 = AltAndFPAMode_2_1;
	ATEng_4_1 = SpeedMode_1_1;
	CASCmd_5_1 = SpeedMode_2_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_2 (In1_1_1 : real; x1_1_1 : real; x2_1_1 : real; y1_1_1 : real; y2_1_1 : real; )
returns (Out1_1_1 : real) ;
var
	Add1_1_1 : real;
	Add2_1_1 : real;
	Add3_1_1 : real;
	Add4_1_1 : real;
	Divide_1_1 : real;
let 
	Add1_1_1 =  - x1_1_1 + x2_1_1;
	Add2_1_1 = Divide_1_1 + y1_1_1;
	Add3_1_1 =  - y1_1_1 + y2_1_1;
	Add4_1_1 = In1_1_1 - x1_1_1;
	-- Divide_1_1 = Add4_1_1 / Add1_1_1 * Add3_1_1;
	Divide_1_1 = times( divid(Add4_1_1, Add1_1_1), Add3_1_1 ) ;
	Out1_1_1 = Add2_1_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_1 (In1_1_1 : real; x1_1_1 : real; x2_1_1 : real; y1_1_1 : real; y2_1_1 : real; )
returns (Out1_1_1 : real) ;
var
	Add1_1_1 : real;
	Add2_1_1 : real;
	Add3_1_1 : real;
	Add4_1_1 : real;
	Divide_1_1 : real;
let 
	Add1_1_1 =  - x1_1_1 + x2_1_1;
	Add2_1_1 = Divide_1_1 + y1_1_1;
	Add3_1_1 =  - y1_1_1 + y2_1_1;
	Add4_1_1 = In1_1_1 - x1_1_1;
	-- Divide_1_1 = Add4_1_1 / Add1_1_1 * Add3_1_1;
	Divide_1_1 = times( divid(Add4_1_1, Add1_1_1), Add3_1_1 ) ;
	Out1_1_1 = Add2_1_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_0 (In1_1_1 : real; x1_1_1 : real; x2_1_1 : real; y1_1_1 : real; y2_1_1 : real; )
returns (Out1_1_1 : real) ;
var
	Add1_1_1 : real;
	Add2_1_1 : real;
	Add3_1_1 : real;
	Add4_1_1 : real;
	Divide_1_1 : real;
let 
	Add1_1_1 =  - x1_1_1 + x2_1_1;
	Add2_1_1 = Divide_1_1 + y1_1_1;
	Add3_1_1 =  - y1_1_1 + y2_1_1;
	Add4_1_1 = In1_1_1 - x1_1_1;
	-- Divide_1_1 = Add4_1_1 / Add1_1_1 * Add3_1_1;
	Divide_1_1 = times( divid(Add4_1_1, Add1_1_1), Add3_1_1 ) ;
	Out1_1_1 = Add2_1_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d (In1_1_1 : real; )
returns (Out1_1_1 : real) ;
var
	Add_1_1 : real;
	branch_sharp_1_1_1 : real;
	branch_sharp_2_1_1 : real;
	branch_sharp_3_1_1 : real;
	gte1_1_1 : bool;
	gte2_1_1 : bool;
	gte3_1_1 : bool;
	interpolate1d_sharp_0_1_1 : real;
	interpolate1d_sharp_1_1_1 : real;
	interpolate1d_sharp_2_1_1 : real;
	lte1_1_1 : bool;
	lte2_1_1 : bool;
	lte3_1_1 : bool;
	r1_1_1 : real;
	r2_1_1 : real;
	r3_1_1 : real;
	r4_1_1 : real;
	r5_1_1 : real;
	r6_1_1 : real;
	r7_1_1 : real;
	r8_1_1 : real;
let 
	Add_1_1 = branch_sharp_1_1_1 + branch_sharp_2_1_1 + branch_sharp_3_1_1;
	-- branch_sharp_1_1_1 = interpolate1d_sharp_0_1_1 * (if lte1_1_1 then 1.0 else 0.0) * (if gte1_1_1 then 1.0 else 0.0);
	branch_sharp_1_1_1 =
		if lte1_1_1 and gte1_1_1 then interpolate1d_sharp_0_1_1 else 0.0 ;
	-- branch_sharp_2_1_1 = interpolate1d_sharp_1_1_1 * (if lte2_1_1 then 1.0 else 0.0) * (if gte2_1_1 then 1.0 else 0.0);
	branch_sharp_2_1_1 =
		if lte2_1_1 and gte2_1_1 then interpolate1d_sharp_1_1_1 else 0.0 ;
	-- branch_sharp_3_1_1 = interpolate1d_sharp_2_1_1 * (if lte3_1_1 then 1.0 else 0.0) * (if gte3_1_1 then 1.0 else 0.0);
	branch_sharp_3_1_1 =
		if lte3_1_1 and gte3_1_1 then interpolate1d_sharp_2_1_1 else 0.0 ;
	gte1_1_1 = In1_1_1 <= r2_1_1;
	gte2_1_1 = In1_1_1 <= r3_1_1;
	gte3_1_1 = In1_1_1 <= r4_1_1;
	interpolate1d_sharp_0_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_0(In1_1_1, r1_1_1, r2_1_1, r5_1_1, r6_1_1);
	interpolate1d_sharp_1_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_1(In1_1_1, r2_1_1, r3_1_1, r6_1_1, r7_1_1);
	interpolate1d_sharp_2_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d_interpolate1d_sharp_2(In1_1_1, r3_1_1, r4_1_1, r7_1_1, r8_1_1);
	lte1_1_1 = In1_1_1 >= r1_1_1;
	lte2_1_1 = In1_1_1 > r2_1_1;
	lte3_1_1 = In1_1_1 > r3_1_1;
	r1_1_1 = 0.0000000000;
	r2_1_1 = 120.0000000000;
	r3_1_1 = 350.0000000000;
	r4_1_1 = 500.0000000000;
	r5_1_1 = 1.0000000000;
	r6_1_1 = 1.0000000000;
	r7_1_1 = 0.3000000000;
	r8_1_1 = 0.3000000000;
	Out1_1_1 = Add_1_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop_TransferFunc (u_1_1 : real; )
returns (y_1_1 : real) ;
var
	a_sharp_1_1_1 : real;
	b0_sharp_0_1_1 : real;
	b0_sharp_1_1_1 : real;
	delay_sharp_1_1_1 : real;
	output_sum_1_1 : real;
	sample_sharp_1_1_1 : real;
	sum11_1_1 : real;
	sum21_1_1 : real;
let 
	a_sharp_1_1_1 = 0.0625000000 * delay_sharp_1_1_1;
	b0_sharp_0_1_1 = 1.0000000000 * u_1_1;
	b0_sharp_1_1_1 = -1.0000000000 * a_sharp_1_1_1;
	delay_sharp_1_1_1 = 0.0000000000 -> pre sum21_1_1;
	output_sum_1_1 = b0_sharp_0_1_1 + b0_sharp_1_1_1;
	sample_sharp_1_1_1 = 0.0200000000 * sum11_1_1;
	sum11_1_1 = u_1_1 - a_sharp_1_1_1;
	sum21_1_1 = sample_sharp_1_1_1 + delay_sharp_1_1_1;
	y_1_1 = output_sum_1_1;
tel

node LONGITUDINAL_CONTROLLER_PitchInnerLoop (PitchCmd_1_1 : real; Pitch_1_1 : real; qdeg_1_1 : real; CAS_1_1 : real; )
returns (ElevCmd_1_1 : real) ;
var
	Kpitch_1_1 : real;
	Kwo_1_1 : real;
	Mux_1_1 : real; Mux_1_2 : real;
	Product_1_1 : real;
	Sum_1_1 : real;
	Sum1_1_1 : real;
	TransferFunc_1_1 : real;
	lookup1d_1_1 : real;
let 
	Kpitch_1_1 = 2.0000000000 * Sum_1_1;
	Kwo_1_1 = 0.5000000000 * TransferFunc_1_1;
	Mux_1_1 = PitchCmd_1_1 ;
	Mux_1_2 = Pitch_1_1 ;
	-- Product_1_1 = Sum1_1_1 * lookup1d_1_1 ;
	Product_1_1 = times(Sum1_1_1, lookup1d_1_1);
	Sum_1_1 = PitchCmd_1_1 - Pitch_1_1;
	Sum1_1_1 =  - Kpitch_1_1 + Kwo_1_1;
	TransferFunc_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop_TransferFunc(qdeg_1_1);
	lookup1d_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop_lookup1d(CAS_1_1);
	ElevCmd_1_1 = Product_1_1;
tel

node LONGITUDINAL_CONTROLLER_ManualOverride (Man_1_1 : real; Auto_1_1 : real; )
returns (Out_1_1 : real) ;
var
	Switch1_1_1 : real;
let 
  -- Switch1_1_1 = if not(Man_1_1 = 0.0) then Auto_1_1 else Man_1_1;
  Switch1_1_1 = if Man_1_1 <> 0.0 then Man_1_1 else Auto_1_1 ;
	Out_1_1 = Switch1_1_1;
tel

node LONGITUDINAL_CONTROLLER_FPAControl_integrator_reset (f_lpar_x_rpar__1_1 : real; reset_level_1_1 : bool; x0_1_1 : real; )
returns (F_lpar_x_rpar__1_1 : real) ;
var
	Add_1_1 : real;
	Constant_1_1 : real;
	Gain1_1_1 : real;
	Product_1_1 : real;
	Product1_1_1 : real;
	Product2_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	Sum3_1_1 : real;
	Sum4_1_1 : real;
	delay_sharp_1_1_1 : real;
	delay_sharp_2_1_1 : real;
	delay_sharp_3_1_1 : bool;
	eq0_1_1 : bool;
	ne0_1_1 : bool;
	ne1_1_1 : bool;
	zero_1_1 : real;
let 
	Add_1_1 = Product1_1_1 + Product2_1_1;
	Constant_1_1 = 0.0000000000;
	Gain1_1_1 = 1.0000000000 * f_lpar_x_rpar__1_1;
  -- Actually linear {
	--   Product_1_1 = x0_1_1 * delay_sharp_1_1_1 ;
  -- }
	-- Product_1_1 = times(x0_1_1, delay_sharp_1_1_1) ;
  Product_1_1 = x0_1_1 -> 0.0 ;
	-- Product1_1_1 = Sum3_1_1 * (if ne0_1_1 then 1.0 else 0.0);
	Product1_1_1 = if ne0_1_1 then Sum3_1_1 else 0.0 ;
	-- Product2_1_1 = (if eq0_1_1 then 1.0 else 0.0) * Sum3_1_1 * (if ne1_1_1 then 1.0 else 0.0);
	Product2_1_1 = if eq0_1_1 and ne1_1_1 then Sum3_1_1 else 0.0 ;
	Sum1_1_1 = Gain1_1_1 + Sum2_1_1;
	Sum2_1_1 = Sum4_1_1 + Product_1_1;
	Sum3_1_1 =  - delay_sharp_2_1_1 + x0_1_1;
	Sum4_1_1 = delay_sharp_2_1_1 + Add_1_1;
	delay_sharp_1_1_1 = 1.0000000000 -> pre Constant_1_1;
	delay_sharp_2_1_1 = 0.0000000000 -> pre Sum1_1_1;
	delay_sharp_3_1_1 = false -> pre reset_level_1_1;
	eq0_1_1 = (if reset_level_1_1 then 1.0 else 0.0) = zero_1_1;
	ne0_1_1 = not((if reset_level_1_1 then 1.0 else 0.0) = zero_1_1);
	ne1_1_1 = not((if delay_sharp_3_1_1 then 1.0 else 0.0) = zero_1_1);
	zero_1_1 = 0.0000000000;
	F_lpar_x_rpar__1_1 = delay_sharp_2_1_1;
tel

node LONGITUDINAL_CONTROLLER_FPAControl_DynamicSaturation (up_1_1 : real; u_1_1 : real; lo_1_1 : real; )
returns (y1_1_1 : real) ;
var
	LowerRelop1_1_1 : bool;
	Switch_1_1 : real;
	Switch2_1_1 : real;
	UpperRelop_1_1 : bool;
let 
	LowerRelop1_1_1 = u_1_1 > up_1_1;
	Switch_1_1 = if UpperRelop_1_1 then lo_1_1 else u_1_1;
	Switch2_1_1 = if LowerRelop1_1_1 then up_1_1 else Switch_1_1;
	UpperRelop_1_1 = u_1_1 < lo_1_1;
	y1_1_1 = Switch2_1_1;
tel

node LONGITUDINAL_CONTROLLER_FPAControl (engage_1_1 : bool; gamcmd_1_1 : real; gamma_1_1 : real; thetadeg_1_1 : real; VT_1_1 : real; )
returns (PitchCmd_1_1 : real) ;

var
	DynamicSaturation_1_1 : real;
	KIgamerr_1_1 : real;
	Kgamerr_1_1 : real;
	LogicalOperator_1_1 : bool;
	Mux_1_1 : real; Mux_1_2 : real;
	Mux1_1_1 : real; Mux1_1_2 : real;
	Product1_1_1 : real;
	Sum_1_1 : real;
	Sum1_1_1 : real;
	Sum2_1_1 : real;
	hddLim1_1_1 : real;
	hddLim2_1_1 : real;
	hddLimProduct_1_1 : real;
	integrator_reset_1_1 : real;
	kt2fps_1_1 : real;
	m1_1_1 : real;
let 
	DynamicSaturation_1_1 = LONGITUDINAL_CONTROLLER_FPAControl_DynamicSaturation(Product1_1_1, KIgamerr_1_1, m1_1_1);
	KIgamerr_1_1 = 1.0000000000 * Sum2_1_1 ;
	Kgamerr_1_1 = 1.4000000000 * gamma_1_1;
	LogicalOperator_1_1 = not engage_1_1;
	Mux_1_1 = gamcmd_1_1 ;
	Mux_1_2 = gamma_1_1 ;
	Mux1_1_1 = Sum2_1_1 ;
	Mux1_1_2 = DynamicSaturation_1_1 ;
  -- Original code, actually linear {
  --   hddLim1_1_1 = 4.8300000000;
  --   hddLim2_1_1 = 57.2958000000;
  --   hddLimProduct_1_1 = hddLim1_1_1 * hddLim2_1_1;
	--   Product1_1_1 = hddLimProduct_1_1 * kt2fps_1_1;
  -- }
  -- Abstraction, useless as it's linear {
  --   hddLim1_1_1 = 4.8300000000;
  --   hddLim2_1_1 = 57.2958000000;
  --   hddLimProduct_1_1 = times(hddLim1_1_1, hddLim2_1_1) ;
	--   Product1_1_1 = times(hddLimProduct_1_1, kt2fps_1_1) ;
  -- }
  -- Instead we just do {
  Product1_1_1 = (4.83 * 57.2958) * kt2fps_1_1 ;
  -- }
	Sum_1_1 = thetadeg_1_1 + Kgamerr_1_1;
	Sum1_1_1 = integrator_reset_1_1 - Kgamerr_1_1;
	Sum2_1_1 = gamcmd_1_1 - gamma_1_1;
	integrator_reset_1_1 = LONGITUDINAL_CONTROLLER_FPAControl_integrator_reset(DynamicSaturation_1_1, LogicalOperator_1_1, Sum_1_1);
	kt2fps_1_1 = 1.6878000000 * VT_1_1;
	m1_1_1 = -1.0000000000 * Product1_1_1;
	PitchCmd_1_1 = Sum1_1_1;
tel

node LONGITUDINAL_CONTROLLER_EngageORzero (Engage_1_1 : bool; In_1_1 : real; )
returns (Out_1_1 : real) ;
var
	LogicalOperator5_1_1 : bool;
	Switch1_1_1 : real;
	zero10_1_1 : real;
	zero9_1_1 : real;
let 
	LogicalOperator5_1_1 = Engage_1_1 and (if zero10_1_1 = 0.0 then false else true);
	Switch1_1_1 = if (if LogicalOperator5_1_1 then 1.0 else 0.0) >= 0.5000000000 then In_1_1 else zero9_1_1;
	zero10_1_1 = 1.0000000000;
	zero9_1_1 = 0.0000000000;
	Out_1_1 = Switch1_1_1;
tel

node LONGITUDINAL_CONTROLLER_AltitudeControl_VariableLimitSaturation (up_lim_1_1 : real; SigIn_1_1 : real; Lo_lim_1_1 : real; )
returns (Out1_1_1 : real) ;
var
	Enforcelowlim_1_1 : real;
	Enforceuplim_1_1 : real;
let 
	Enforcelowlim_1_1 = if Lo_lim_1_1 >= SigIn_1_1 then Lo_lim_1_1 else SigIn_1_1;
	Enforceuplim_1_1 = if Enforcelowlim_1_1 <= up_lim_1_1 then Enforcelowlim_1_1 else up_lim_1_1;
	Out1_1_1 = Enforceuplim_1_1;
tel

node LONGITUDINAL_CONTROLLER_AltitudeControl_VariableRateLimit_VariableLimitSaturation (up_lim_1_1 : real; SigIn_1_1 : real; Lo_lim_1_1 : real; )
returns (Out1_1_1 : real) ;
var
	Enforcelowlim_1_1 : real;
	Enforceuplim_1_1 : real;
let 
	Enforcelowlim_1_1 = if Lo_lim_1_1 >= SigIn_1_1 then Lo_lim_1_1 else SigIn_1_1;
	Enforceuplim_1_1 = if Enforcelowlim_1_1 <= up_lim_1_1 then Enforcelowlim_1_1 else up_lim_1_1;
	Out1_1_1 = Enforceuplim_1_1;
tel

node LONGITUDINAL_CONTROLLER_AltitudeControl_VariableRateLimit (ratelim_1_1 : real; input_1_1 : real; ICtrig_1_1 : bool; IC_1_1 : real; )
returns (output_1_1 : real) ;

(* This holds. *)
(*
--@var clamped = clamp(
  -ratelim_1_1, 20.0 * (input_1_1 - output_1_1), ratelim_1_1
) ;

--@require ratelim_1_1 = 3.2 ;
--@require ICtrig_1_1 => input_1_1 = 0.0 ;

--@mode no_ic_trig ;
--@require not ICtrig_1_1 ;

--@mode ic_trig_init ;
--@require ICtrig_1_1 and (true -> not pre ICtrig_1_1) ;

--@mode ic_trig ;
--@require false -> ICtrig_1_1 and pre ICtrig_1_1 ;
--@ensure true -> duration(true) >= 3 => output_1_1 <=  3.2 + pre IC_1_1 ;
--@ensure true -> duration(true) >= 3 => output_1_1 >= -3.2 + pre IC_1_1 ;
--@ensure true -> (
  (duration(true) = 2 and pre ICtrig_1_1) => output_1_1 = 2.0 * pre IC_1_1
) ;
*)

var
	Gain_1_1 : real;
	Gain1_1_1 : real;
	Sum2_1_1 : real;
	VariableLimitSaturation_1_1 : real;
	integrator_reset_Add_1_1 : real;
	integrator_reset_Constant_1_1 : real;
	integrator_reset_Gain1Reset_1_1 : real;
	integrator_reset_Product_1_1 : real;
	integrator_reset_Product1_1_1 : real;
	integrator_reset_Product2_1_1 : real;
	integrator_reset_Sum1_1_1 : real;
	integrator_reset_Sum2Reset_1_1 : real;
	integrator_reset_Sum3_1_1 : real;
	integrator_reset_Sum4_1_1 : real;
	integrator_reset_delay_sharp_1_1_1 : real;
	integrator_reset_delay_sharp_2_1_1 : real;
	integrator_reset_delay_sharp_3_1_1 : bool;
	integrator_reset_eq0_1_1 : bool;
	integrator_reset_ne0_1_1 : bool;
	integrator_reset_ne1_1_1 : bool;
	integrator_reset_zero_1_1 : real;
let 
	Gain_1_1 = 20.0000000000 * Sum2_1_1;
	Gain1_1_1 = -1.0000000000 * ratelim_1_1;
	Sum2_1_1 = input_1_1 - integrator_reset_delay_sharp_2_1_1;
	VariableLimitSaturation_1_1 = LONGITUDINAL_CONTROLLER_AltitudeControl_VariableRateLimit_VariableLimitSaturation(ratelim_1_1, Gain_1_1, Gain1_1_1);
	integrator_reset_Add_1_1 = integrator_reset_Product1_1_1 + integrator_reset_Product2_1_1;
	integrator_reset_Constant_1_1 = 0.0000000000;
	integrator_reset_Gain1Reset_1_1 = 1.0000000000 * VariableLimitSaturation_1_1;
	-- integrator_reset_Product_1_1 = IC_1_1 * integrator_reset_delay_sharp_1_1_1;
  integrator_reset_Product_1_1 = IC_1_1 -> 0.0 ;
	-- integrator_reset_Product1_1_1 = integrator_reset_Sum3_1_1 * (if integrator_reset_ne0_1_1 then 1.0 else 0.0);
	integrator_reset_Product1_1_1 =
		if integrator_reset_ne0_1_1 then integrator_reset_Sum3_1_1 else 0.0 ;
	-- integrator_reset_Product2_1_1 = (if integrator_reset_eq0_1_1 then 1.0 else 0.0) * integrator_reset_Sum3_1_1 * (if integrator_reset_ne1_1_1 then 1.0 else 0.0);
	integrator_reset_Product2_1_1 =
		if integrator_reset_eq0_1_1 and integrator_reset_ne1_1_1
		then integrator_reset_Sum3_1_1 else 0.0 ;
	integrator_reset_Sum1_1_1 = integrator_reset_Gain1Reset_1_1 + integrator_reset_Sum2Reset_1_1;
	integrator_reset_Sum2Reset_1_1 = integrator_reset_Sum4_1_1 + integrator_reset_Product_1_1;
	integrator_reset_Sum3_1_1 =  - integrator_reset_delay_sharp_2_1_1 + IC_1_1;
	integrator_reset_Sum4_1_1 = integrator_reset_delay_sharp_2_1_1 + integrator_reset_Add_1_1;
	integrator_reset_delay_sharp_1_1_1 = 1.0000000000 -> pre integrator_reset_Constant_1_1;
	integrator_reset_delay_sharp_2_1_1 = 0.0000000000 -> pre integrator_reset_Sum1_1_1;
	integrator_reset_delay_sharp_3_1_1 = false -> pre ICtrig_1_1;
	integrator_reset_eq0_1_1 = (if ICtrig_1_1 then 1.0 else 0.0) = integrator_reset_zero_1_1;
	integrator_reset_ne0_1_1 = not((if ICtrig_1_1 then 1.0 else 0.0) = integrator_reset_zero_1_1);
	integrator_reset_ne1_1_1 = not((if integrator_reset_delay_sharp_3_1_1 then 1.0 else 0.0) = integrator_reset_zero_1_1);
	integrator_reset_zero_1_1 = 0.0000000000;
	output_1_1 = integrator_reset_delay_sharp_2_1_1;
tel

node LONGITUDINAL_CONTROLLER_AltitudeControl_Saturation1 (SigIn_1_1 : real; )
returns (Out1_1_1 : real) ;
var
	Constant1_1_1 : real;
	Constant2_1_1 : real;
	Enforcelowlim_1_1 : real;
	Enforceuplim_1_1 : real;
let 
	Constant1_1_1 = 0.0001000000;
	Constant2_1_1 = 1000.0000000000;
	Enforcelowlim_1_1 = if Constant1_1_1 >= SigIn_1_1 then Constant1_1_1 else SigIn_1_1;
	Enforceuplim_1_1 = if Enforcelowlim_1_1 <= Constant2_1_1 then Enforcelowlim_1_1 else Constant2_1_1;
	Out1_1_1 = Enforceuplim_1_1;
tel

node LONGITUDINAL_CONTROLLER_AltitudeControl (engage_1_1 : bool; AltCmd_1_1 : real; Altitude_1_1 : real; gskts_1_1 : real; hdot_1_1 : real; )
returns (altgamcmd_1_1 : real) ;

var
	Abs_1_1 : real;
	Constant1_1_1 : real;
	Constant3_1_1 : real;
	Constant4_1_1 : real;
	Divide_1_1 : real;
	Kh_1_1 : real;
	LogicalOperator_1_1 : bool;
	Mux_1_1 : real; Mux_1_2 : real;
	Mux1_1_1 : real; Mux1_1_2 : real;
	Saturation1_1_1 : real;
	Sum_1_1 : real;
	Sum3_1_1 : real;
	Switch_1_1 : real;
	VariableRateLimit_1_1 : real;
	VariableLimitSaturation_1_1 : real;
	k_1_1 : real;
	kts2fps_1_1 : real;
	r2d_1_1 : real;
let 
	Abs_1_1 = if hdot_1_1 >= 0.0 then hdot_1_1 else -hdot_1_1;
	Constant1_1_1 = 0.0000000000;
	Constant3_1_1 = 10.0000000000;
	Constant4_1_1 = 3.2000000000;
  -- Divide_1_1 = VariableRateLimit_1_1 / Saturation1_1_1;
  -- Divide_1_1 = temporal_divid(VariableRateLimit_1_1, Saturation1_1_1);
	-- Divide_1_1 = divid_fun(VariableRateLimit_1_1, Saturation1_1_1);
  Divide_1_1 = if gskts_1_1 >= 100.0 then divid_bounded_den(
    VariableRateLimit_1_1,
    if gskts_1_1 < 100.0 then 200.0 else Saturation1_1_1,
    168.78,
    1000.0
  ) else divid_bounded_den(
    VariableRateLimit_1_1, Saturation1_1_1, 0.0001, 1000.0
  ) ;
	Kh_1_1 = 0.0800000000 * Sum_1_1;
	LogicalOperator_1_1 = not engage_1_1;
	Mux_1_1 = AltCmd_1_1 ;
	Mux_1_2 = Altitude_1_1 ;
	Mux1_1_1 = VariableLimitSaturation_1_1 ;
	Mux1_1_2 = VariableRateLimit_1_1 ;
	Saturation1_1_1 = LONGITUDINAL_CONTROLLER_AltitudeControl_Saturation1(kts2fps_1_1);
	Sum_1_1 = AltCmd_1_1 - Altitude_1_1;
	Sum3_1_1 = Abs_1_1 + Constant3_1_1;
  (* |===| Bug, >= should be >. *)
  -- Switch_1_1 = if (if engage_1_1 then 1.0 else 0.0) >= 0.0000000000 then Kh_1_1 else Constant1_1_1;
	Switch_1_1 = if engage_1_1 then Kh_1_1 else Constant1_1_1 ;
	VariableRateLimit_1_1 = LONGITUDINAL_CONTROLLER_AltitudeControl_VariableRateLimit(Constant4_1_1, VariableLimitSaturation_1_1, LogicalOperator_1_1, hdot_1_1);
	VariableLimitSaturation_1_1 = LONGITUDINAL_CONTROLLER_AltitudeControl_VariableLimitSaturation(Sum3_1_1, Switch_1_1, k_1_1);
	k_1_1 = -1.0000000000 * Sum3_1_1;
	kts2fps_1_1 = 1.6878000000 * gskts_1_1;
	r2d_1_1 = 57.2958000000 * Divide_1_1;
	altgamcmd_1_1 = r2d_1_1;
tel

node LONGITUDINAL_CONTROLLER (FPACmd_1_1 : real; AltEng_1_1 : bool; FpaEng_1_1 : bool; AltCmd_1_1 : real; Alt_1_1 : real; thetaDeg_1_1 : real; qDeg_1_1 : real; GsKts_1_1 : real; hdot_1_1 : real; VT_1_1 : real; Gamma_1_1 : real; CAS_1_1 : real; ElevStick_1_1 : real; )
returns (alt_cmd_out, pitch_cmd_out, ElevCmd_1_1 : real) ;

var
	AltitudeControl_1_1 : real;
	EngageORzero_1_1 : real;
	FPAControl_1_1 : real;
	LogicalOperator_1_1 : bool;
	ManualOverride_1_1 : real;
	PitchInnerLoop_1_1 : real;
	Sum7_1_1 : real;
  act_cmd_ge_cmd, alt_out_loc_pos : bool ;
	k2_1_1 : real;
	k5_1_1 : real;
let 
	AltitudeControl_1_1 = LONGITUDINAL_CONTROLLER_AltitudeControl(AltEng_1_1, AltCmd_1_1, Alt_1_1, GsKts_1_1, hdot_1_1);
	EngageORzero_1_1 = LONGITUDINAL_CONTROLLER_EngageORzero(LogicalOperator_1_1, PitchInnerLoop_1_1);
	FPAControl_1_1 = LONGITUDINAL_CONTROLLER_FPAControl(FpaEng_1_1, Sum7_1_1, Gamma_1_1, thetaDeg_1_1, VT_1_1);
	LogicalOperator_1_1 = AltEng_1_1 or FpaEng_1_1;
	ManualOverride_1_1 = LONGITUDINAL_CONTROLLER_ManualOverride(ElevStick_1_1, EngageORzero_1_1);
	PitchInnerLoop_1_1 = LONGITUDINAL_CONTROLLER_PitchInnerLoop(k5_1_1, thetaDeg_1_1, qDeg_1_1, CAS_1_1);
	Sum7_1_1 = FPACmd_1_1 + k2_1_1;
  act_cmd_ge_cmd = Sum7_1_1 >= FPACmd_1_1 ;
  alt_out_loc_pos = k2_1_1 >= 0.0 ;
	k2_1_1 = 1.0000000000 * AltitudeControl_1_1;
	k5_1_1 = 1.0000000000 * FPAControl_1_1;
	ElevCmd_1_1 = ManualOverride_1_1;
  pitch_cmd_out = if act_cmd_ge_cmd or not act_cmd_ge_cmd then
    if alt_out_loc_pos or not alt_out_loc_pos then FPAControl_1_1 else 0.0
    else 0.0 ;
  alt_cmd_out = AltitudeControl_1_1 ;
tel

node Mode_plus_Longitudinal (
	head_mode : real ;
	ail_stick_in : real ;
	elev_stick_in : real ;
  -- Altitude mode.
	alt_mode : real ;
  -- Flight Path Angle mode.
	fpa_mode : real ;
  -- Auto Throttle mode.
	at_mode : real ;
	alt_cmd_in : real ;
	alt_in : real ;
	cas_in : real ;
	cas_cmd : real ;
	pitch_in : real ;
	qbdegf_1_1 : real ;
	gskts_in : real ;
	hdot_in : real ;
	speed_in : real ;
	fpa_in : real ;
	fpa_cmd_in : real ;
) returns (
	head_eng_out, alt_eng_out, at_eng_out, fpa_eng_out : bool ;
	cas_cmd_out, alt_cmd_out, pitch_cmd_out, elev_cmd_out : real ;
) ;

(*@contract

  (* Helpers for component activation. *)
  var alt_eng_in = (alt_mode <> 0.0) ;
  var fpa_eng_in = (fpa_mode <> 0.0) ;
  var head_eng_in = (head_mode <> 0.0) ;
  var deactivate = (ail_stick_in <> 0.0 or elev_stick_in <> 0.0) ;
  var deactivation = false -> pre deactivate ;
  var pre_fpa_cmd_in = fpa_cmd_in -> pre fpa_cmd_in ;

  var pre_elev_cmd_out = elev_cmd_out -> pre elev_cmd_out ;
  var pre_pitch_cmd_out = pitch_cmd_out -> pre pitch_cmd_out ;

  var fpa_cmd_delta_lb = 0.0 -> (-3.2 + pre hdot_in) * 0.34 ;
  var fpa_cmd_delta_ub = 0.0 -> ( 3.2 + pre hdot_in) * 0.34 ;
  var fpa_cmd_in_lb = fpa_cmd_in + fpa_cmd_delta_lb ;
  var fpa_cmd_in_ub = fpa_cmd_in + fpa_cmd_delta_ub ;

  (* When CAS is greater than 500 FPA and Altitude mode output 0. *)
  var going_too_fast = cas_in > 500.0 ;

  (* Climbing means that the pitch command is above the current pitch, above
    its previous value, or that FPA is expected to reach / go above the FPA
    command in the next step. *)
  var is_climbing = 
    pitch_cmd_out > pitch_in or
    pitch_cmd_out >= pre_pitch_cmd_out or
    fpa_cmd_in_lb <= fpa_in + (0.0 -> fpa_in - pre fpa_in) ;

  (* Descending means that the pitch command is below the current pitch, below
    its previous value, or that FPA is expected to reach/ go below the FPA
    command in the next step. *)
  var is_descending =
    pitch_cmd_out < pitch_in or
    pitch_cmd_out <= pre_pitch_cmd_out or
    fpa_cmd_in_ub >= fpa_in + (0.0 -> fpa_in - pre fpa_in) ;

  (* Alt requested and no deactivation since then. *)
  var alt_requested =
    has_been_true_reset(alt_eng_in, deactivation and not alt_eng_in) ;
  (* FPA requested and no deactivation since then. *)
  var fpa_requested =
    has_been_true_reset(fpa_eng_in, deactivation and not fpa_eng_in) ;
  (* Head requested and no deactivation since then. *)
  var head_requested =
    has_been_true_reset(head_eng_in, deactivation and not head_eng_in) ;

  (* Separates Guide 210 (not far_altitude_gap) from Guide 170/180
    (far_altitude_gap). In the former Alt has priority, while in the latter
    it's FPA. *)
  var far_altitude_gap = abs(alt_in - alt_cmd_in) > 200.0 ;

  (* See "MODE_LOGIC_HeadingMode" for an explanation of the following. *)
  @require true ->
    (since(head_eng_in) = 1) => (pre since(not head_eng_in) > 1) ;
  @require true ->
    (since(not head_eng_in) = 1) => (pre since(head_eng_in) > 1) ;
  (* See "MODE_LOGIC_AltAndFPAMode" for an explanation of the following. *)
  @require true ->
    (since(alt_eng_in) = 1) => (pre since(not alt_eng_in) > 1) ;
  @require true ->
    (since(not alt_eng_in) = 1) => (pre since(alt_eng_in) > 1) ;
  @require true ->
    (since(fpa_eng_in) = 1) => (pre since(not fpa_eng_in) > 1) ;
  @require true ->
    (since(not fpa_eng_in) = 1) => (pre since(fpa_eng_in) > 1) ;
  @require true ->
    (since(deactivate) = 1) => (pre since(not deactivate) > 1) ;
  @require true ->
    (since(not deactivate) = 1) => (pre since(deactivate) > 1) ;

  (* System does not behave well when an input and deactivate fall at the same
    time. *)
  @require fall(alt_eng_in) => not fall(deactivate) ;
  @require fall(fpa_eng_in) => not fall(deactivate) ;
  (* System does not behave well when an input and deactivate fall at the same
    time. *)
  @require fall(head_eng_in) => not fall(deactivate) ;

  @require alt_in >= 0.0 ;
  @require alt_cmd_in >= 0.0 ;
  @require fpa_cmd_in >= 0.0 ;

  @require PseudoContinuous(alt_in, 1.0) ;
  @require PseudoContinuous(hdot_in, 1.0) ;

  (* hdot semantics. *)
  @require true -> alt_in = hdot_in + pre alt_in ;

  (* All speed inputs are positive. *)
  @require gskts_in >= 0.0 ;
  @require speed_in >= 0.0 ;
  @require cas_in >= 0.0 ;

  (* Pitch converges towards pitch command. *)
  @require true -> (
    pre fpa_eng_out => (
      abs(pitch_in - pre_pitch_cmd_out) < pre abs(pitch_in - pitch_cmd_out) or
      (pre pitch_in) = pre_pitch_cmd_out
    )
  ) ;

  (* Link between pitch and FPA. *)
  (* FPA and theta have same sign, and abs(fpa) < (theta). *)
  @require (pitch_in = 0.0 => fpa_in = 0.0) ;
  @require true -> (
    pitch_in > 0.0 => (
      pitch_in > fpa_in and fpa_in >= pitch_in / 1.4
    )
  ) ;
  @require true -> (
    pitch_in < 0.0 => (
      pitch_in / 1.4 >= fpa_in and fpa_in > pitch_in
    )
  ) ;
  (* Derivatives of FPA and pitch have the same sign. *)
  @require true -> (
    ( (pitch_in > pre pitch_in) = (fpa_in > pre fpa_in) ) and
    ( (pitch_in < pre pitch_in) = (fpa_in < pre fpa_in) ) and
    ( (pitch_in = pre pitch_in) = (fpa_in = pre fpa_in) )
  ) ;



  (* ## Engage assumptions. *)

  (* Cannot be engaged if speed is less than 100. *)
  @require (fpa_eng_out or alt_eng_out) => speed_in >= 100.0 ;
  @require (fpa_eng_out or alt_eng_out) => gskts_in >= 100.0 ;
  @require (fpa_eng_out or alt_eng_out) => cas_in   >= 100.0 ;

  @require fall(alt_eng_out) => not fpa_eng_out ;

  (* Whatever happens, altitude control and FPA control can't be active at the
    same time. *)
  @ensure not (alt_eng_out and fpa_eng_out) ;


  @mode inactive (
    @require duration(not (alt_eng_in or fpa_eng_in or head_eng_in)) > 0 ;
    @ensure not (alt_eng_out or fpa_eng_out or head_eng_in) ;
  ) ;

  (* When deactivated no one is active. *)
  @mode deactivated (
    (* No collision with inactive mode. *)
    @require not inactive ;
    @require not alt_requested ;
    @require not fpa_requested ;
    @require not head_requested ;
    @ensure not (alt_eng_out or fpa_eng_out or head_eng_out) ;
  ) ;

  (* |===| Guide 170.
    Alt does not have priority. It cannot be active if FPA was requested since
    the beginning / last deactivation, or if a deactivation happened since the
    last request for Alt. *)
  @mode guide_170_alt (
    @require far_altitude_gap ;
    @require alt_requested ;
    @require not fpa_requested ;
    @ensure alt_eng_out ;
  ) ;

  (* |===| Guide 180.
    FPA has priority. It is active if no deactivation happened since the last
    FPA request. *)
  @mode guide_180_fpa (
    @require far_altitude_gap ;
    @require fpa_requested ;
    @ensure fpa_eng_out ;
  ) ;

  (* |===| Guide 210, Alt mode.
    Alt has priority. It is active if no deactivation happened since the last
    Alt request. *)
  @mode guide_210_alt (
    @require not far_altitude_gap ;
    @require alt_requested ;
    @ensure alt_eng_out ;
  ) ;

  (* |===| Guide 210, FPA mode.
    FPA does not have priority. It cannot be active if Alt was requested since
    the beginning / last deactivation, or if a deactivation happened since the
    last request for FPA. *)
  @mode guide_210_fpa (
    @require not far_altitude_gap ;
    @require fpa_requested ;
    @require not alt_requested ;
    @ensure fpa_eng_out ;
  ) ;

  (* Altitude and FPA modes cannot be engaged outside of the spec. *)
  @mode alt_and_fpa_inactive (
    (* No intersection with deactivated. *)
    @require not deactivated ;
    @require not (
      guide_170_alt or guide_180_fpa or guide_210_alt or guide_210_fpa
    ) ;
    @ensure not (fpa_eng_out or alt_eng_out) ;
  ) ;

  (* |===| Guide 250. *)
  @mode guide_250 (
    @require head_requested ;
    @ensure head_eng_out ;
  ) ;



  (* ## Modes for FPA / Altitude modes. *)


  (* Elevation stick bypasses everything. *)
  @mode manual_override (
    @require elev_stick_in <> 0.0 ;
    @ensure elev_cmd_out = elev_stick_in ;
  ) ;

  (* When disengaged and there's no manual override output is zero. *)
  @mode disengaged (
    @require not (
      guide_170_alt or guide_180_fpa or guide_210_alt or guide_210_fpa
    ) ;
    @require not manual_override ;
    @ensure elev_cmd_out = 0.0 ;
  ) ;

  (* If CAS is above 500.0 and there's no manual override output of
    longitudinal mode is zero. *)
  @mode too_fast (
    @require not manual_override ;
    @require not disengaged ;
    @require going_too_fast ;
    @ensure elev_cmd_out = 0.0 ;
  ) ;

  @mode fpa_engaging (
    @require not manual_override ;
    @require not going_too_fast ;
    @require (guide_180_fpa or guide_210_fpa) -> rise(
      guide_180_fpa or guide_210_fpa
    ) ;
  ) ;

  (* |===| Guide 120, climbing at a defined rate. *)
  @mode fpa_g120 (
    @require not manual_override ;
    @require not going_too_fast ;
    @require guide_180_fpa or guide_210_fpa ;
    @require false -> pre (guide_180_fpa or guide_210_fpa) ;
    @require false -> (
      (* (-3.2 + pre hdot_in) * 0.34 is the lower bound on alt_cmd_out when alt
        is not engaged. *)
      fpa_cmd_in_lb > fpa_in
    ) ;
    @ensure (
      (* Not confirmed that we're climbing. *)
      (false -> pre (fpa_cmd_in_lb <= fpa_in)) or
      (* Pitch was at pitch command. *)
      (false -> pre (pitch_in = pitch_cmd_out)) or
      (* Climbing. *)
      is_climbing or
      (* We're not climbing but we were in the previous state. *)
      ( not is_climbing and (false -> pre is_climbing) )
    ) ;
  ) ;

  (* |===| Guide 130, descending at a defined rate. *)
  @mode fpa_g130 (
    @require not manual_override ;
    @require not going_too_fast ;
    @require guide_180_fpa or guide_210_fpa ;
    @require false -> pre (guide_180_fpa or guide_210_fpa) ;
    @require false -> (
      (* (+3.2 + pre hdot_in) * 0.34 is the lower bound on alt_cmd_out when alt
        is not engaged. *)
      fpa_cmd_in_ub < fpa_in
    ) ;
    @ensure (
      (* Not confirmed that we're descending. *)
      (false -> pre (fpa_cmd_in_ub >= fpa_in)) or
      (* Pitch was at pitch command. *)
      (false -> pre (pitch_in = pitch_cmd_out)) or
      (* Descending. *)
      is_descending or
      (* We're not descending but we were in the previous state. *)
      ( not is_descending and (false -> pre is_descending) )
    ) ;
  ) ;

  (* |===| Guide 120_130, stabilizing version.
    Things get tricky when we get to the requested FPA.
    Not sure what the ensure should be here. *)
  @mode g120_130_stabilizing (
    @require not manual_override ;
    @require not going_too_fast ;
    @require guide_180_fpa or guide_210_fpa ;
    @require false -> (fpa_cmd_in_lb >= fpa_in) ;
    @require false -> (fpa_cmd_in_ub <= fpa_in) ;
  ) ;

*)

let 
	(
		head_eng_out,
	  alt_eng_out,
	  fpa_eng_out,
	  at_eng_out,
	  cas_cmd_out
  ) = MODE_LOGIC(
  	head_mode,
  	ail_stick_in,
  	elev_stick_in,
  	alt_mode,
  	fpa_mode,
  	at_mode,
  	alt_cmd_in,
  	alt_in,
  	cas_in,
  	cas_cmd
	);

	(alt_cmd_out, pitch_cmd_out, elev_cmd_out) = LONGITUDINAL_CONTROLLER(
		fpa_cmd_in,
		alt_eng_out,
		fpa_eng_out,
		alt_cmd_in,
		alt_in,
		pitch_in,
		qbdegf_1_1,
		gskts_in,
		hdot_in,
		speed_in,
		fpa_in,
		cas_in,
		elev_stick_in
	);

tel

